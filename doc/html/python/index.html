<?xml version="1.0" encoding="iso-8859-1" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html>

  <head>
    <title>CODA Python</title>
    <link rel="stylesheet" href="../css/codadoc.css" type="text/css" />
  </head>

  <body>

    <div class="main">

      <h1>CODA Python</h1>

      <p>The CODA Python interface consists of a Python package 'coda' containing extensive functionality to access data inside product files.</p>

      <p>There are three ways to use the CODA Python interface. The recommended approach is to use a set of high-level classes as described below. There are also several functions that resemble the <a href="../matlab/index.html">CODA MATLAB interface</a>. For this, see the high-level functions as described below. Finally, the interface also contains a direct wrapping (using CFFI) of the <a href="../libcoda/index.html">CODA C interface</a>. It is not recommended to use this interface directly, as it exists mainly for backward compatibility.</p>

      <p>The CODA Python interface depends on the '_cffi_backend' module, which is part of the C foreign function interface (cffi) package. This package must be installed in order to be able to use the Python interface.</p>

      <h2>Contents</h2>

      <ul>
        <li><a href="#codadef">CODA Definition Path</a></li>
        <li><a href="#high_level_types">High level CODA Data Types</a></li>
        <li><a href="#high_level_classes">High level CODA Classes</a>
          <ul>
            <li><a href="#coda.Error"><code>coda.Error</code></a></li>
            <li><a href="#coda.FetchError"><code>coda.FetchError</code></a></li>
            <li><a href="#coda.CodacError"><code>coda.CodacError</code></a></li>
            <li><a href="#coda.Node"><code>coda.Node</code></a></li>
            <li><a href="#coda.Product"><code>coda.Product</code></a></li>
            <li><a href="#coda.Cursor"><code>coda.Cursor</code></a></li>
            <li><a href="#coda.Record"><code>coda.Record</code></a></li>
            <li><a href="#coda.Type"><code>coda.Type</code></a></li>
            <li><a href="#coda.IntegerType"><code>coda.IntegerType</code></a></li>
            <li><a href="#coda.RealType"><code>coda.RealType</code></a></li>
            <li><a href="#coda.RecordType"><code>coda.RecordType</code></a></li>
            <li><a href="#coda.ArrayType"><code>coda.ArrayType</code></a></li>
            <li><a href="#coda.SpecialType"><code>coda.SpecialType</code></a></li>
            <li><a href="#coda.TextType"><code>coda.TextType</code></a></li>
            <li><a href="#coda.RawType"><code>coda.RawType</code></a></li>
            <li><a href="#coda.Expression"><code>coda.Expression</code></a></li>
          </ul>
        </li>
        <li><a href="#high_level_functions">High level CODA Functions</a>
          <ul>
            <li><a href="#coda_open_hl"><code>coda.open</code></a></li>
            <li><a href="#coda_open_as_hl"><code>coda.open_as</code></a></li>
            <li><a href="#coda_close_hl"><code>coda.close</code></a></li>
            <li><a href="#coda_get_attributes"><code>coda.get_attributes</code></a></li>
            <li><a href="#coda_get_description"><code>coda.get_description</code></a></li>
            <li><a href="#coda_fetch"><code>coda.fetch</code></a></li>
            <li><a href="#coda_get_field_available"><code>coda.get_field_available</code></a></li>
            <li><a href="#coda_get_field_count"><code>coda.get_field_count</code></a></li>
            <li><a href="#coda_get_field_names"><code>coda.get_field_names</code></a></li>
            <li><a href="#coda_get_size"><code>coda.get_size</code></a></li>
            <li><a href="#coda_time_to_string"><code>coda.time_to_string</code></a></li>
            <li><a href="#coda_time_to_utcstring"><code>coda.time_to_utcstring</code></a></li>
            <li><a href="#coda_get_unit"><code>coda.get_unit</code></a></li>
            <li><a href="#coda_version"><code>coda.version</code></a></li>
            <li><a href="#coda_set_option_filter_record_fields"><code>coda.set_option_filter_record_fields</code></a></li>
            <li><a href="#coda_get_option_filter_record_fields"><code>coda.get_option_filter_record_fields</code></a></li>
          </ul>
        </li>
        <li><a href="#low_level_types">Low level CODA Data Types</a></li>
        <li><a href="#low_level_functions">Low level CODA Functions</a>
          <ul>
            <li><a href="#coda_init"><code>coda.init</code></a></li>
            <li><a href="#coda_done"><code>coda.done</code></a></li>
            <li><a href="#coda_set_option_bypass_special_types"><code>coda.set_option_bypass_special_types</code></a></li>
            <li><a href="#coda_get_option_bypass_special_types"><code>coda.get_option_bypass_special_types</code></a></li>
            <li><a href="#coda_set_option_perform_boundary_checks"><code>coda.set_option_perform_boundary_checks</code></a></li>
            <li><a href="#coda_get_option_perform_boundary_checks"><code>coda.get_option_perform_boundary_checks</code></a></li>
            <li><a href="#coda_set_option_perform_conversions"><code>coda.set_option_perform_conversions</code></a></li>
            <li><a href="#coda_get_option_perform_conversions"><code>coda.get_option_perform_conversions</code></a></li>
            <li><a href="#coda_set_option_use_fast_size_expressions"><code>coda.set_option_use_fast_size_expressions</code></a></li>
            <li><a href="#coda_get_option_use_fast_size_expressions"><code>coda.get_option_use_fast_size_expressions</code></a></li>
            <li><a href="#coda_set_option_use_mmap"><code>coda.set_option_use_mmap</code></a></li>
            <li><a href="#coda_get_option_use_mmap"><code>coda.get_option_use_mmap</code></a></li>
            <li><a href="#coda_NaN"><code>coda.NaN</code></a></li>
            <li><a href="#coda_isNaN"><code>coda.isNaN</code></a></li>
            <li><a href="#coda_PlusInf"><code>coda.PlusInf</code></a></li>
            <li><a href="#coda_MinInf"><code>coda.MinInf</code></a></li>
            <li><a href="#coda_isInf"><code>coda.isInf</code></a></li>
            <li><a href="#coda_isPlusInf"><code>coda.isPlusInf</code></a></li>
            <li><a href="#coda_isMinInf"><code>coda.isMinInf</code></a></li>
            <li><a href="#coda_c_index_to_fortran_index"><code>coda.c_index_to_fortran_index</code></a></li>
            <li><a href="#coda_match_filefilter"><code>coda.match_filefilter</code></a></li>
            <li><a href="#coda_time_double_to_parts"><code>coda.time_double_to_parts</code></a></li>
            <li><a href="#coda_time_double_to_parts_utc"><code>coda.time_double_to_parts_utc</code></a></li>
            <li><a href="#coda_time_parts_to_double_utc"><code>coda.time_parts_to_double_utc</code></a></li>
            <li><a href="#coda_time_parts_to_string"><code>coda.time_parts_to_string</code></a></li>
            <li><a href="#coda_time_string_to_parts"><code>coda.time_string_to_parts</code></a></li>
            <li><a href="#coda_time_double_to_string"><code>coda.time_double_to_string</code></a></li>
            <li><a href="#coda_time_double_to_string_utc"><code>coda.time_double_to_string_utc</code></a></li>
            <li><a href="#coda_time_string_to_double"><code>coda.time_string_to_double</code></a></li>
            <li><a href="#coda_time_string_to_double_utc"><code>coda.time_string_to_double_utc</code></a></li>
            <li><a href="#coda_recognize_file"><code>coda.recognize_file</code></a></li>
            <li><a href="#coda_open"><code>coda.open</code></a></li>
            <li><a href="#coda_open_as"><code>coda.open_as</code></a></li>
            <li><a href="#coda_close"><code>coda.close</code></a></li>
            <li><a href="#coda_get_product_filename"><code>coda.get_product_filename</code></a></li>
            <li><a href="#coda_get_product_file_size"><code>coda.get_product_file_size</code></a></li>
            <li><a href="#coda_get_product_format"><code>coda.get_product_format</code></a></li>
            <li><a href="#coda_get_product_class"><code>coda.get_product_class</code></a></li>
            <li><a href="#coda_get_product_type"><code>coda.get_product_type</code></a></li>
            <li><a href="#coda_get_product_version"><code>coda.get_product_version</code></a></li>
            <li><a href="#coda_get_product_root_type"><code>coda.get_product_root_type</code></a></li>
            <li><a href="#coda_get_product_variable_value"><code>coda.get_product_variable_value</code></a></li>
            <li><a href="#coda_type_get_format_name"><code>coda.type_get_format_name</code></a></li>
            <li><a href="#coda_type_get_class_name"><code>coda.type_get_class_name</code></a></li>
            <li><a href="#coda_type_get_native_type_name"><code>coda.type_get_native_type_name</code></a></li>
            <li><a href="#coda_type_get_special_type_name"><code>coda.type_get_special_type_name</code></a></li>
            <li><a href="#coda_type_has_attributes"><code>coda.type_has_attributes</code></a></li>
            <li><a href="#coda_type_get_format"><code>coda.type_get_format</code></a></li>
            <li><a href="#coda_type_get_class"><code>coda.type_get_class</code></a></li>
            <li><a href="#coda_type_get_read_type"><code>coda.type_get_read_type</code></a></li>
            <li><a href="#coda_type_get_string_length"><code>coda.type_get_string_length</code></a></li>
            <li><a href="#coda_type_get_bit_size"><code>coda.type_get_bit_size</code></a></li>
            <li><a href="#coda_type_get_name"><code>coda.type_get_name</code></a></li>
            <li><a href="#coda_type_get_description"><code>coda.type_get_description</code></a></li>
            <li><a href="#coda_type_get_unit"><code>coda.type_get_unit</code></a></li>
            <li><a href="#coda_type_get_fixed_value"><code>coda.type_get_fixed_value</code></a></li>
            <li><a href="#coda_type_get_attributes"><code>coda.type_get_attributes</code></a></li>
            <li><a href="#coda_type_get_num_record_fields"><code>coda.type_get_num_record_fields</code></a></li>
            <li><a href="#coda_type_get_record_field_index_from_name"><code>coda.type_get_record_field_index_from_name</code></a></li>
            <li><a href="#coda_type_get_record_field_index_from_real_name"><code>coda.type_get_record_field_index_from_real_name</code></a></li>
            <li><a href="#coda_type_get_record_field_type"><code>coda.type_get_record_field_type</code></a></li>
            <li><a href="#coda_type_get_record_field_name"><code>coda.type_get_record_field_name</code></a></li>
            <li><a href="#coda_type_get_record_field_real_name"><code>coda.type_get_record_field_real_name</code></a></li>
            <li><a href="#coda_type_get_record_field_hidden_status"><code>coda.type_get_record_field_hidden_status</code></a></li>
            <li><a href="#coda_type_get_record_field_available_status"><code>coda.type_get_record_field_available_status</code></a></li>
            <li><a href="#coda_type_get_record_union_status"><code>coda.type_get_record_union_status</code></a></li>
            <li><a href="#coda_type_get_array_num_dims"><code>coda.type_get_array_num_dims</code></a></li>
            <li><a href="#coda_type_get_array_dim"><code>coda.type_get_array_dim</code></a></li>
            <li><a href="#coda_type_get_array_base_type"><code>coda.type_get_array_base_type</code></a></li>
            <li><a href="#coda_type_get_special_type"><code>coda.type_get_special_type</code></a></li>
            <li><a href="#coda_type_get_special_base_type"><code>coda.type_get_special_base_type</code></a></li>
            <li><a href="#coda_cursor_set_product"><code>coda.cursor_set_product</code></a></li>
            <li><a href="#coda_cursor_goto"><code>coda.cursor_goto</code></a></li>
            <li><a href="#coda_cursor_goto_first_record_field"><code>coda.cursor_goto_first_record_field</code></a></li>
            <li><a href="#coda_cursor_goto_next_record_field"><code>coda.cursor_goto_next_record_field</code></a></li>
            <li><a href="#coda_cursor_goto_record_field_by_index"><code>coda.cursor_goto_record_field_by_index</code></a></li>
            <li><a href="#coda_cursor_goto_record_field_by_name"><code>coda.cursor_goto_record_field_by_name</code></a></li>
            <li><a href="#coda_cursor_goto_available_union_field"><code>coda.cursor_goto_available_union_field</code></a></li>
            <li><a href="#coda_cursor_goto_first_array_element"><code>coda.cursor_goto_first_array_element</code></a></li>
            <li><a href="#coda_cursor_goto_next_array_element"><code>coda.cursor_goto_next_array_element</code></a></li>
            <li><a href="#coda_cursor_goto_array_element"><code>coda.cursor_goto_array_element</code></a></li>
            <li><a href="#coda_cursor_goto_array_element_by_index"><code>coda.cursor_goto_array_element_by_index</code></a></li>
            <li><a href="#coda_cursor_goto_attributes"><code>coda.cursor_goto_attributes</code></a></li>
            <li><a href="#coda_cursor_goto_root"><code>coda.cursor_goto_root</code></a></li>
            <li><a href="#coda_cursor_goto_parent"><code>coda.cursor_goto_parent</code></a></li>
            <li><a href="#coda_cursor_use_base_type_of_special_type"><code>coda.cursor_use_base_type_of_special_type</code></a></li>
            <li><a href="#coda_cursor_has_ascii_content"><code>coda.cursor_has_ascii_content</code></a></li>
            <li><a href="#coda_cursor_has_attributes"><code>coda.cursor_has_attributes</code></a></li>
            <li><a href="#coda_cursor_get_string_length"><code>coda.cursor_get_string_length</code></a></li>
            <li><a href="#coda_cursor_get_bit_size"><code>coda.cursor_get_bit_size</code></a></li>
            <li><a href="#coda_cursor_get_byte_size"><code>coda.cursor_get_byte_size</code></a></li>
            <li><a href="#coda_cursor_get_num_elements"><code>coda.cursor_get_num_elements</code></a></li>
            <li><a href="#coda_cursor_get_product_file"><code>coda.cursor_get_product_file</code></a></li>
            <li><a href="#coda_cursor_get_depth"><code>coda.cursor_get_depth</code></a></li>
            <li><a href="#coda_cursor_get_index"><code>coda.cursor_get_index</code></a></li>
            <li><a href="#coda_cursor_get_file_bit_offset"><code>coda.cursor_get_file_bit_offset</code></a></li>
            <li><a href="#coda_cursor_get_file_byte_offset"><code>coda.cursor_get_file_byte_offset</code></a></li>
            <li><a href="#coda_cursor_get_format"><code>coda.cursor_get_format</code></a></li>
            <li><a href="#coda_cursor_get_type_class"><code>coda.cursor_get_type_class</code></a></li>
            <li><a href="#coda_cursor_get_read_type"><code>coda.cursor_get_read_type</code></a></li>
            <li><a href="#coda_cursor_get_special_type"><code>coda.cursor_get_special_type</code></a></li>
            <li><a href="#coda_cursor_get_type"><code>coda.cursor_get_type</code></a></li>
            <li><a href="#coda_cursor_get_record_field_index_from_name"><code>coda.cursor_get_record_field_index_from_name</code></a></li>
            <li><a href="#coda_cursor_get_record_field_available_status"><code>coda.cursor_get_record_field_available_status</code></a></li>
            <li><a href="#coda_cursor_get_available_union_field_index"><code>coda.cursor_get_available_union_field_index</code></a></li>
            <li><a href="#coda_cursor_get_array_dim"><code>coda.cursor_get_array_dim</code></a></li>
            <li><a href="#coda_cursor_read_int8"><code>coda.cursor_read_int8</code></a></li>
            <li><a href="#coda_cursor_read_uint8"><code>coda.cursor_read_uint8</code></a></li>
            <li><a href="#coda_cursor_read_int16"><code>coda.cursor_read_int16</code></a></li>
            <li><a href="#coda_cursor_read_uint16"><code>coda.cursor_read_uint16</code></a></li>
            <li><a href="#coda_cursor_read_int32"><code>coda.cursor_read_int32</code></a></li>
            <li><a href="#coda_cursor_read_uint32"><code>coda.cursor_read_uint32</code></a></li>
            <li><a href="#coda_cursor_read_int64"><code>coda.cursor_read_int64</code></a></li>
            <li><a href="#coda_cursor_read_uint64"><code>coda.cursor_read_uint64</code></a></li>
            <li><a href="#coda_cursor_read_float"><code>coda.cursor_read_float</code></a></li>
            <li><a href="#coda_cursor_read_double"><code>coda.cursor_read_double</code></a></li>
            <li><a href="#coda_cursor_read_char"><code>coda.cursor_read_char</code></a></li>
            <li><a href="#coda_cursor_read_string"><code>coda.cursor_read_string</code></a></li>
            <li><a href="#coda_cursor_read_bits"><code>coda.cursor_read_bits</code></a></li>
            <li><a href="#coda_cursor_read_bytes"><code>coda.cursor_read_bytes</code></a></li>
            <li><a href="#coda_cursor_read_int8_array"><code>coda.cursor_read_int8_array</code></a></li>
            <li><a href="#coda_cursor_read_uint8_array"><code>coda.cursor_read_uint8_array</code></a></li>
            <li><a href="#coda_cursor_read_int16_array"><code>coda.cursor_read_int16_array</code></a></li>
            <li><a href="#coda_cursor_read_uint16_array"><code>coda.cursor_read_uint16_array</code></a></li>
            <li><a href="#coda_cursor_read_int32_array"><code>coda.cursor_read_int32_array</code></a></li>
            <li><a href="#coda_cursor_read_uint32_array"><code>coda.cursor_read_uint32_array</code></a></li>
            <li><a href="#coda_cursor_read_int64_array"><code>coda.cursor_read_int64_array</code></a></li>
            <li><a href="#coda_cursor_read_uint64_array"><code>coda.cursor_read_uint64_array</code></a></li>
            <li><a href="#coda_cursor_read_float_array"><code>coda.cursor_read_float_array</code></a></li>
            <li><a href="#coda_cursor_read_double_array"><code>coda.cursor_read_double_array</code></a></li>
            <li><a href="#coda_cursor_read_char_array"><code>coda.cursor_read_char_array</code></a></li>
            <li><a href="#coda_cursor_read_int8_partial_array"><code>coda.cursor_read_int8_partial_array</code></a></li>
            <li><a href="#coda_cursor_read_uint8_partial_array"><code>coda.cursor_read_uint8_partial_array</code></a></li>
            <li><a href="#coda_cursor_read_int16_partial_array"><code>coda.cursor_read_int16_partial_array</code></a></li>
            <li><a href="#coda_cursor_read_uint16_partial_array"><code>coda.cursor_read_uint16_partial_array</code></a></li>
            <li><a href="#coda_cursor_read_int32_partial_array"><code>coda.cursor_read_int32_partial_array</code></a></li>
            <li><a href="#coda_cursor_read_uint32_partial_array"><code>coda.cursor_read_uint32_partial_array</code></a></li>
            <li><a href="#coda_cursor_read_int64_partial_array"><code>coda.cursor_read_int64_partial_array</code></a></li>
            <li><a href="#coda_cursor_read_uint64_partial_array"><code>coda.cursor_read_uint64_partial_array</code></a></li>
            <li><a href="#coda_cursor_read_float_partial_array"><code>coda.cursor_read_float_partial_array</code></a></li>
            <li><a href="#coda_cursor_read_double_partial_array"><code>coda.cursor_read_double_partial_array</code></a></li>
            <li><a href="#coda_cursor_read_char_partial_array"><code>coda.cursor_read_char_partial_array</code></a></li>
            <li><a href="#coda_cursor_read_complex_double_pair"><code>coda.cursor_read_complex_double_pair</code></a></li>
            <li><a href="#coda_cursor_read_complex_double_pairs_array"><code>coda.cursor_read_complex_double_pairs_array</code></a></li>
            <li><a href="#coda_cursor_read_complex_double_split"><code>coda.cursor_read_complex_double_split</code></a></li>
            <li><a href="#coda_cursor_read_complex_double_split_array"><code>coda.cursor_read_complex_double_split_array</code></a></li>
            <li><a href="#coda_expression_get_type_name"><code>coda.expression_get_type_name</code></a></li>
            <li><a href="#coda_expression_from_string"><code>coda.expression_from_string</code></a></li>
            <li><a href="#coda_expression_delete"><code>coda.expression_delete</code></a></li>
            <li><a href="#coda_expression_get_type"><code>coda.expression_get_type</code></a></li>
            <li><a href="#coda_expression_is_constant"><code>coda.expression_is_constant</code></a></li>
            <li><a href="#coda_expression_is_equal"><code>coda.expression_is_equal</code></a></li>
            <li><a href="#coda_expression_eval_bool"><code>coda.expression_eval_bool</code></a></li>
            <li><a href="#coda_expression_eval_integer"><code>coda.expression_eval_integer</code></a></li>
            <li><a href="#coda_expression_eval_float"><code>coda.expression_eval_float</code></a></li>
            <li><a href="#coda_expression_eval_string"><code>coda.expression_eval_string</code></a></li>
            <li><a href="#coda_expression_eval_node"><code>coda.expression_eval_node</code></a></li>
          </ul>
        </li>
      </ul>


      <h2 id="codadef">CODA Definition Path</h2>
      
      <p>To access products whose formats are defined using .codadef files, you should let CODA now where these .codadef files are stored. By default the CODA Python interface will look for .codadef files in a directory relative to the location of the CODA Python package (<code>../../../../share/coda/definitions</code>).

      <p>You can override the default location by setting the CODA_DEFINITION environment variable. This environment variable should be a ':' separated (';' on Windows) list of absolute paths to directories containing .codadef files or absolute paths to .codadef files themselves (or a mix of those).</p>

      <p>When you import the CODA Python package this will trigger an initialisation of CODA, so you should make sure that the CODA_DEFINITION environment variable is set before you import the CODA Python package. Setting the environment variable can be performed from within Python using:</p>

<div class="fragment"><pre>
import os

os.putenv('CODA_DEFINITION', '&lt;your codadef search path&gt;')

# ...

import coda
</pre></div>
      

      <h2 id="high_level_types">High level CODA Data Types</h2>

      <p>When reading data from a product file, CODA will use the following mapping to translate the ingested data into Python data structures:</p>

      <table class="fancy">
        <tr><th>CODA&nbsp;class</th><th>CODA&nbsp;read&nbsp;type / CODA&nbsp;special&nbsp;type</th><th>Python data type</th></tr>
        <tr><td>record</td><td>&nbsp;</td><td><code>coda.Record</code></td></tr>
        <tr><td>array</td><td>&nbsp;</td><td>This will be a numpy array (<code>numpy.array</code>) object. The following table relates the CODA array base type to the numpy base type:
           <table class="fancy">
             <tr><th>CODA&nbsp;class</th><th>CODA&nbsp;read&nbsp;type / CODA&nbsp;special&nbsp;type</th><th>numpy base type</th></tr>
             <tr><td>record</td><td>&nbsp;</td><td>Python object (<code>coda.Record</code>)</td></tr>
             <tr><td>array</td><td>&nbsp;</td><td>Python object (a <code>numpy.array</code> object)</td></tr>
             <tr><td>integer</td><td>int8</td><td>int8</td></tr>
             <tr><td>integer</td><td>uint8</td><td>uint8</td></tr>
             <tr><td>integer</td><td>int16</td><td>int16</td></tr>
             <tr><td>integer</td><td>uint16</td><td>uint16</td></tr>
             <tr><td>integer</td><td>int32</td><td>int32</td></tr>
             <tr><td>integer</td><td>uint32</td><td>uint32</td></tr>
             <tr><td>integer</td><td>int64</td><td>int64</td></tr>
             <tr><td>integer</td><td>uint64</td><td>uint64</td></tr>
             <tr><td>real</td><td>float</td><td>float32</td></tr>
             <tr><td>real</td><td>double</td><td>float64</td></tr>
             <tr><td>text</td><td>char</td><td>Python object (the Python object is a Python String of length 1)</td></tr>
             <tr><td>text</td><td>string</td><td>Python object (Python String)</td></tr>
             <tr><td>raw</td><td>bytes</td><td>Python object (<code>numpy.array</code> object with base type uint8)</td></tr>
             <tr><td>special</td><td>no_data</td><td>Python object (<code>None</code>)</td></tr>
             <tr><td>special</td><td>time</td><td>float64</td></tr>
             <tr><td>special</td><td>complex</td><td>complex64</td></tr>
           </table>   
        </td></tr>
        <tr><td>integer</td><td>int8</td><td>Python Integer</td></tr>
        <tr><td>integer</td><td>uint8</td><td>Python Integer</td></tr>
        <tr><td>integer</td><td>int16</td><td>Python Integer</td></tr>
        <tr><td>integer</td><td>uint16</td><td>Python Integer</td></tr>
        <tr><td>integer</td><td>int32</td><td>Python Integer</td></tr>
        <tr><td>integer</td><td>uint32</td><td>Python Long</td></tr>
        <tr><td>integer</td><td>int64</td><td>Python Long</td></tr>
        <tr><td>integer</td><td>uint64</td><td>Python Long</td></tr>
        <tr><td>real</td><td>float</td><td>Python Float</td></tr>
        <tr><td>real</td><td>double</td><td>Python Float</td></tr>
        <tr><td>text</td><td>char</td><td>Python String</td></tr>
        <tr><td>text</td><td>string</td><td>Python String</td></tr>
        <tr><td>raw</td><td>bytes</td><td><code>numpy.array</code> object with base type uint8</td></tr>
        <tr><td>special</td><td>no_data</td><td><code>None</code></td></tr>
        <tr><td>special</td><td>time</td><td>Python Float</td></tr>
        <tr><td>special</td><td>complex</td><td>Python Complex Number</td></tr>
      </table>


<a name="high_level_classes"></a>
<h2 id="high_level_classes">High level CODA Classes</h2>

<p>The high-level classes form an object-oriented wrapper layer around the low-level functionality and add some additional convenience methods</p>

<p>A CODA Product is represented by an instance of class Product. One or more instances of class Cursor can be used to navigate a product, and extract CODA types and product data. CODA types are represented as instances of class Type. There are several subclasses of Type, corresponding to the different CODA type classes. A CODA expression is represented by an instance of class Expression.</p>

<p>Example of basic usage:</p>

<div class="fragment"><pre>
import coda

with coda.Product('somefile.nc') as product:
    # use cursor
    cursor = product.cursor()
    cursor.goto('a/b')
    data = cursor.fetch()

    # use convenience method
    data = product.fetch('a/b')
</pre></div>

<p><a name="coda.Error"></a></p>

<h2>Error Objects</h2>

<p><code>python
class Error(Exception)
</code></p>

<p>Exception base class for all CODA Python interface errors.</p>

<p><a name="coda.FetchError"></a></p>

<h2>FetchError Objects</h2>

<p><code>python
class FetchError(Error)
</code></p>

<p>Exception raised when an errors occurs when fetching data.</p>

<p><strong>Attributes</strong>:</p>

<ul>
<li><code>str</code> - error message</li>
</ul>

<p><a name="coda.CodacError"></a></p>

<h2>CodacError Objects</h2>

<p><code>python
class CodacError(Error)
</code></p>

<p>Exception raised when an error occurs inside the CODA C library.</p>

<p><strong>Attributes</strong>:</p>

<ul>
<li><code>errno</code> - error code; if None, the error code will be retrieved from
the CODA C library.</li>
<li><code>strerror</code> - error message; if None, the error message will be retrieved
from the CODA C library.</li>
</ul>

<p><a name="coda.Node"></a></p>

<h2>Node Objects</h2>

<p><code>python
class Node(object)
</code></p>

<p>Base class of 'Product' and 'Cursor' classes.</p>

<p>This class contains shared functionality between Product and Cursor.
For this functionality, a Product can be used as if it were a Cursor
(pointing at the product root).</p>

<p><a name="coda.Node.fetch"></a></p>

<h4>fetch</h4>

<p><code>python
 | fetch(*path)
</code></p>

<p>Return all product data (recursively) for the current data item
(or as specified by a path).</p>

<p>This can result in a combination of nested 'Record' instances,
numpy arrays, scalars, strings and so on.</p>

<p>Some examples:</p>

<p>data = product.fetch('fieldname')
data = cursor.fetch('a/b')</p>

<p><strong>Arguments</strong>:</p>

<ul>
<li><code>path</code> - path description (optional)</li>
</ul>

<p><a name="coda.Node.get_attributes"></a></p>

<h4>get_attributes</h4>

<p><code>python
 | get_attributes(*path)
</code></p>

<p>Return a 'Record' instance containing the attributes for the
current data item (or as specified by a path).</p>

<p><strong>Arguments</strong>:</p>

<ul>
<li><code>path</code> - path description (optional)</li>
</ul>

<p><a name="coda.Node.attributes"></a></p>

<h4>attributes</h4>

<p><code>python
 | @property
 | attributes()
</code></p>

<p>Return a 'Record' instance containing the attributes for the
current data item.</p>

<p><a name="coda.Node.get_description"></a></p>

<h4>get_description</h4>

<p><code>python
 | get_description(*path)
</code></p>

<p>Return the description in the product format definition for the
current data item (or as specified by a path).</p>

<p><strong>Arguments</strong>:</p>

<ul>
<li><code>path</code> - path description (optional)</li>
</ul>

<p><a name="coda.Node.description"></a></p>

<h4>description</h4>

<p><code>python
 | @property
 | description()
</code></p>

<p>Return the description (as a string) in the product format
definition for the current data item.</p>

<p><a name="coda.Node.get_unit"></a></p>

<h4>get_unit</h4>

<p><code>python
 | @property
 | get_unit(*path)
</code></p>

<p>Return unit information (as a string) in the product format
definition for the current data item (or as specified by a path).</p>

<p><strong>Arguments</strong>:</p>

<ul>
<li><code>path</code> - path description (optional)</li>
</ul>

<p><a name="coda.Node.unit"></a></p>

<h4>unit</h4>

<p><code>python
 | @property
 | unit()
</code></p>

<p>Return unit information (as a string) in the product format
definition for the current data item.</p>

<p><a name="coda.Node.cursor"></a></p>

<h4>cursor</h4>

<p><code>python
 | cursor(*path)
</code></p>

<p>Return a new 'Cursor' instance, pointing to the same data
item (or as specified by a path).</p>

<p><strong>Arguments</strong>:</p>

<ul>
<li><code>path</code> - path description (optional)</li>
</ul>

<p><a name="coda.Node.read_partial_array"></a></p>

<h4>read_partial_array</h4>

<p><code>python
 | read_partial_array(offset, count)
</code></p>

<p>Return partial (flat) array data, using specified offset and count.</p>

<p>C array ordering conventions are used.</p>

<p><strong>Arguments</strong>:</p>

<ul>
<li><code>offset</code> - (flat) array index</li>
<li><code>count</code> - number of elements to read</li>
</ul>

<p><a name="coda.Node.field_available"></a></p>

<h4>field_available</h4>

<p><code>python
 | field_available(*path)
</code></p>

<p>Return a boolean indicating whether a record field is available.</p>

<p>The last item of the path description must point to a record field.</p>

<p><strong>Arguments</strong>:</p>

<ul>
<li><code>path</code> - path description (optional)</li>
</ul>

<p><a name="coda.Node.field_count"></a></p>

<h4>field_count</h4>

<p><code>python
 | field_count(*path)
</code></p>

<p>Return the number of fields in a record.</p>

<p>The last item of the path must point to a record.</p>

<p><strong>Arguments</strong>:</p>

<ul>
<li><code>path</code> - path description (optional)</li>
</ul>

<p><a name="coda.Node.field_names"></a></p>

<h4>field_names</h4>

<p><code>python
 | field_names(*path)
</code></p>

<p>Return the names of the fields in a record.</p>

<p>The last item of the path must point to a record.</p>

<p><strong>Arguments</strong>:</p>

<ul>
<li><code>path</code> - path description (optional)</li>
</ul>

<p><a name="coda.Product"></a></p>

<h2>Product Objects</h2>

<p><code>python
class Product(Node)
</code></p>

<p>CODA Product class.</p>

<p>An instance of this class represents a CODA product.</p>

<p>It is a wrapper class around the low-level coda_product struct.</p>

<p>It implements the context-manager protocol for conveniently
closing (these low-level) products.</p>

<p><a name="coda.Product.__init__"></a></p>

<h4>__init__</h4>

<p><code>python
 | __init__(path)
</code></p>

<p>Initialize a 'Product' instance for specified product file.</p>

<p>The instance should be cleaned up after use via 'with' keyword or
by calling the 'close' method (or global function).</p>

<p><strong>Arguments</strong>:</p>

<ul>
<li><code>path</code> - path to product file</li>
</ul>

<p><a name="coda.Product.close"></a></p>

<h4>close</h4>

<p><code>python
 | close()
</code></p>

<p>Close the low-level CODA product.</p>

<p>Note that it is also possible to use the 'with' keyword for this.</p>

<p><a name="coda.Product.version"></a></p>

<h4>version</h4>

<p><code>python
 | @property
 | version()
</code></p>

<p>Return the product type version.</p>

<p><a name="coda.Product.product_class"></a></p>

<h4>product_class</h4>

<p><code>python
 | @property
 | product_class()
</code></p>

<p>Return the name of the product class.</p>

<p><a name="coda.Product.product_type"></a></p>

<h4>product_type</h4>

<p><code>python
 | @property
 | product_type()
</code></p>

<p>Return the name of the product type.</p>

<p><a name="coda.Product.format"></a></p>

<h4>format</h4>

<p><code>python
 | @property
 | format()
</code></p>

<p>Return the name of the product format.</p>

<p><a name="coda.Product.definition_file"></a></p>

<h4>definition_file</h4>

<p><code>python
 | @property
 | definition_file()
</code></p>

<p>Return the path to the coda definition file that describes the product format.</p>

<p><a name="coda.Product.file_size"></a></p>

<h4>file_size</h4>

<p><code>python
 | @property
 | file_size()
</code></p>

<p>Return the product file size.</p>

<p><a name="coda.Product.filename"></a></p>

<h4>filename</h4>

<p><code>python
 | @property
 | filename()
</code></p>

<p>Return the product filename.</p>

<p><a name="coda.Product.root_type"></a></p>

<h4>root_type</h4>

<p><code>python
 | @property
 | root_type()
</code></p>

<p>Return the CODA type of the root of the product.</p>

<p><a name="coda.Product.variable_value"></a></p>

<h4>variable_value</h4>

<p><code>python
 | variable_value(variable, index=0)
</code></p>

<p>Return the value for a product variable.</p>

<p>Product variables are used to store frequently needed
information of a product (information that is needed to
calculate byte offsets or array sizes within a product).</p>

<p>Consult the CODA Product Definition Documentation for
an overview of product variables for a certain product type.</p>

<p>Product variables can be one-dimensional arrays, in which an
index must be passed.</p>

<p><strong>Arguments</strong>:</p>

<ul>
<li><code>variable</code> - name of product variable</li>
<li><code>index</code> - array index of the product variable (optional)</li>
</ul>

<p><a name="coda.Cursor"></a></p>

<h2>Cursor Objects</h2>

<p><code>python
class Cursor(Node)
</code></p>

<p>CODA Cursor class.</p>

<p>An instance of this class represents a CODA cursor.</p>

<p>It is a wrapper class around the low-level coda_cursor struct.</p>

<p>Cursors are used to navigate a product hierarchy, and
extract CODA types and product data.</p>

<p>Internally, a 'Cursor' instance consists of a stack of pointers,
making it is possible to easily move up and down a product hierarchy.</p>

<p><a name="coda.Cursor.__init__"></a></p>

<h4>__init__</h4>

<p><code>python
 | __init__(obj=None, *path)
</code></p>

<p>Initialize a 'Cursor' instance.</p>

<p>If a 'Cursor' instance is passed, the cursor will point to the
same location.</p>

<p>If a 'Product' instance is passed, the cursor will point to the
product root.</p>

<p>If a path is given, the cursor location will then be changed
to point as specified.</p>

<p>If no arguments are given, the 'set_product' method should be
used to point to a 'Product' instance.</p>

<p><strong>Arguments</strong>:</p>

<ul>
<li><code>obj</code> - existing 'Cursor' or 'Product' instance (optional)</li>
<li><code>path</code> - path description (optional)</li>
</ul>

<p><a name="coda.Cursor.goto"></a></p>

<h4>goto</h4>

<p><code>python
 | goto(*path)
</code></p>

<p>Move the cursor as specified by 'path'.</p>

<p><strong>Arguments</strong>:</p>

<ul>
<li><code>path</code> - path description (optional)</li>
</ul>

<p><a name="coda.Cursor.goto_parent"></a></p>

<h4>goto_parent</h4>

<p><code>python
 | goto_parent()
</code></p>

<p>Move the cursor one level up in the hierarchy.</p>

<p><a name="coda.Cursor.goto_root"></a></p>

<h4>goto_root</h4>

<p><code>python
 | goto_root()
</code></p>

<p>Move the cursor to the product root.</p>

<p><a name="coda.Cursor.goto_first_record_field"></a></p>

<h4>goto_first_record_field</h4>

<p><code>python
 | goto_first_record_field()
</code></p>

<p>Move the cursor to the first record field.</p>

<p><a name="coda.Cursor.goto_next_record_field"></a></p>

<h4>goto_next_record_field</h4>

<p><code>python
 | goto_next_record_field()
</code></p>

<p>Move the cursor to the next record field.</p>

<p><a name="coda.Cursor.goto_record_field_by_index"></a></p>

<h4>goto_record_field_by_index</h4>

<p><code>python
 | goto_record_field_by_index(index)
</code></p>

<p>Move the cursor to the record field with the given index.</p>

<p><strong>Arguments</strong>:</p>

<ul>
<li><code>index</code> - field index</li>
</ul>

<p><a name="coda.Cursor.goto_record_field_by_name"></a></p>

<h4>goto_record_field_by_name</h4>

<p><code>python
 | goto_record_field_by_name(name)
</code></p>

<p>Move the cursor to the record field with the given name.</p>

<p><strong>Arguments</strong>:</p>

<ul>
<li><code>index</code> - field name</li>
</ul>

<p><a name="coda.Cursor.goto_first_array_element"></a></p>

<h4>goto_first_array_element</h4>

<p><code>python
 | goto_first_array_element()
</code></p>

<p>Move the cursor to the first array element.</p>

<p><a name="coda.Cursor.goto_next_array_element"></a></p>

<h4>goto_next_array_element</h4>

<p><code>python
 | goto_next_array_element()
</code></p>

<p>Move the cursor to the next array element.</p>

<p><a name="coda.Cursor.goto_array_element"></a></p>

<h4>goto_array_element</h4>

<p><code>python
 | goto_array_element(idcs)
</code></p>

<p>Move the cursor to the array element with the given indices.</p>

<p><strong>Arguments</strong>:</p>

<ul>
<li><code>idcs</code> - sequence of indices (one per dimension)</li>
</ul>

<p><a name="coda.Cursor.goto_array_element_by_index"></a></p>

<h4>goto_array_element_by_index</h4>

<p><code>python
 | goto_array_element_by_index(index)
</code></p>

<p>Move the cursor to the array element with the given index.</p>

<p>A multi-dimensional array is treated as a one-dimensional array
(with the same number of elements).</p>

<p>The ordering in such a one dimensional array is by definition
chosen to be equal to the way the array elements are stored as a
sequence in the product file.</p>

<p>The mapping of a one dimensional index for each multidimensional
data array to an array of subscripts (and vice versa) is defined
in such a way that the last element of a subscript array is the
one that is the fastest running index (i.e. C array ordering).</p>

<p>All multidimensional arrays have their dimensions defined using C
array ordering in CODA.</p>

<p><strong>Arguments</strong>:</p>

<ul>
<li><code>index</code> - array index</li>
</ul>

<p><a name="coda.Cursor.goto_available_union_field"></a></p>

<h4>goto_available_union_field</h4>

<p><code>python
 | goto_available_union_field()
</code></p>

<p>Move the cursor to the available union field.</p>

<p><a name="coda.Cursor.goto_attributes"></a></p>

<h4>goto_attributes</h4>

<p><code>python
 | goto_attributes()
</code></p>

<p>Move the cursor to a (virtual) record containing the attributes
of the current data element.</p>

<p><a name="coda.Cursor.set_product"></a></p>

<h4>set_product</h4>

<p><code>python
 | set_product(product)
</code></p>

<p>Initialize the cursor to point to the given product root.</p>

<p><strong>Arguments</strong>:</p>

<ul>
<li><code>product</code> - 'Product' instance</li>
</ul>

<p><a name="coda.Cursor.product"></a></p>

<h4>product</h4>

<p><code>python
 | @property
 | product()
</code></p>

<p>Return the corresponding 'Product' instance.</p>

<p><a name="coda.Cursor.num_elements"></a></p>

<h4>num_elements</h4>

<p><code>python
 | num_elements()
</code></p>

<p>Return the number of array or record elements (or 1 for other
types.</p>

<p><a name="coda.Cursor.string_length"></a></p>

<h4>string_length</h4>

<p><code>python
 | string_length()
</code></p>

<p>Return the length in bytes of a string.</p>

<p><a name="coda.Cursor.use_base_type_of_special_type"></a></p>

<h4>use_base_type_of_special_type</h4>

<p><code>python
 | use_base_type_of_special_type()
</code></p>

<p>Reinterpret special data using the special type base type.</p>

<p>All special data types have a base type that can be used to read
the data in its raw form (e.g. for ASCII time data the type will
change to a string type and for binary compound time data the type
will change to a record with fields containing binary numbers).</p>

<p><a name="coda.Cursor.coda_type"></a></p>

<h4>coda_type</h4>

<p><code>python
 | @property
 | coda_type()
</code></p>

<p>Return a 'Type' instance corresponding to the CODA type for
the current location.</p>

<p><a name="coda.Cursor.type_class"></a></p>

<h4>type_class</h4>

<p><code>python
 | @property
 | type_class()
</code></p>

<p>Return the name of the CODA type class for the current
location.</p>

<p><a name="coda.Cursor.special_type"></a></p>

<h4>special_type</h4>

<p><code>python
 | @property
 | special_type()
</code></p>

<p>Return the name of the special type for the current
location.</p>

<p><a name="coda.Cursor.format"></a></p>

<h4>format</h4>

<p><code>python
 | @property
 | format()
</code></p>

<p>Return the name of the storage format for the current
location.</p>

<p><a name="coda.Cursor.has_attributes"></a></p>

<h4>has_attributes</h4>

<p><code>python
 | @property
 | has_attributes()
</code></p>

<p>Return a boolean indicating if there are attributes for
the current location.</p>

<p><a name="coda.Cursor.has_ascii_content"></a></p>

<h4>has_ascii_content</h4>

<p><code>python
 | @property
 | has_ascii_content()
</code></p>

<p>Return a boolean indicating if the data for the current
location is stored in ASCII format.</p>

<p><a name="coda.Cursor.available_union_field_index"></a></p>

<h4>available_union_field_index</h4>

<p><code>python
 | @property
 | available_union_field_index()
</code></p>

<p>Return the index of the available union field.</p>

<p><a name="coda.Cursor.record_field_available_status"></a></p>

<h4>record_field_available_status</h4>

<p><code>python
 | record_field_available_status(index)
</code></p>

<p>Return a boolean indicating if a record field is available.</p>

<p><strong>Arguments</strong>:</p>

<ul>
<li><code>index</code> - record field index</li>
</ul>

<p><a name="coda.Cursor.record_field_index_from_name"></a></p>

<h4>record_field_index_from_name</h4>

<p><code>python
 | record_field_index_from_name(name)
</code></p>

<p>Return record field index for the field with the given name.</p>

<p><strong>Arguments</strong>:</p>

<ul>
<li><code>name</code> - record field name</li>
</ul>

<p><a name="coda.Cursor.array_dim"></a></p>

<h4>array_dim</h4>

<p><code>python
 | @property
 | array_dim()
</code></p>

<p>Return a list containing the dimensions of an array.</p>

<p><a name="coda.Cursor.depth"></a></p>

<h4>depth</h4>

<p><code>python
 | @property
 | depth()
</code></p>

<p>Return the hierarchical depth of the current location.</p>

<p><a name="coda.Cursor.index"></a></p>

<h4>index</h4>

<p><code>python
 | @property
 | index()
</code></p>

<p>Return the array or record field index for the current location.</p>

<p>For arrays, a 'flat' index is returned (similator to the argument
of the 'goto<em>array</em>element<em>by</em>index' method).</p>

<p><a name="coda.Cursor.bit_size"></a></p>

<h4>bit_size</h4>

<p><code>python
 | bit_size()
</code></p>

<p>Return the bit size for the current location.</p>

<p><a name="coda.Cursor.byte_size"></a></p>

<h4>byte_size</h4>

<p><code>python
 | byte_size()
</code></p>

<p>Return the byte size for the current location.</p>

<p>It is calculated by rounding <em>up</em> the bit size to the nearest byte.</p>

<p><a name="coda.Cursor.file_bit_offset"></a></p>

<h4>file_bit_offset</h4>

<p><code>python
 | @property
 | file_bit_offset()
</code></p>

<p>Return the file offset in bits for the current location.</p>

<p><a name="coda.Cursor.file_byte_offset"></a></p>

<h4>file_byte_offset</h4>

<p><code>python
 | @property
 | file_byte_offset()
</code></p>

<p>Return the file offset in bytes for the current location.</p>

<p>It is calculated by rounding <em>down</em> the bit offset to the nearest
byte.</p>

<p><a name="coda.Record"></a></p>

<h2>Record Objects</h2>

<p><code>python
class Record(object)
</code></p>

<p>CODA Record class.</p>

<p>An instance of this class represents a CODA record.</p>

<p>Each record field will appear as an instance attribute. The field
name is used as the name of the attribute, and its value is read from
the product file.</p>

<p><a name="coda.Type"></a></p>

<h2>Type Objects</h2>

<p><code>python
class Type(object)
</code></p>

<p>CODA Type base class.</p>

<p>An instance of this class represents a CODA type.</p>

<p>It is a wrapper class around the low-level coda_type struct.</p>

<p>Specialized functionality corresponding to the different CODA
types is provided by the following subclasses:</p>

<ul>
<li>'IntegerType'</li>
<li>'RealType'</li>
<li>'RecordType'</li>
<li>'ArrayType'</li>
<li>'SpecialType'</li>
<li>'TextType'</li>
<li>'RawType'</li>
</ul>

<p><a name="coda.Type.type_class"></a></p>

<h4>type_class</h4>

<p><code>python
 | @property
 | type_class()
</code></p>

<p>Return the name of the type class.</p>

<p><a name="coda.Type.format"></a></p>

<h4>format</h4>

<p><code>python
 | @property
 | format()
</code></p>

<p>Return the name of the type storage format.</p>

<p><a name="coda.Type.special_type"></a></p>

<h4>special_type</h4>

<p><code>python
 | @property
 | special_type()
</code></p>

<p>Return the name of the special type.</p>

<p><a name="coda.Type.description"></a></p>

<h4>description</h4>

<p><code>python
 | @property
 | description()
</code></p>

<p>Return the type description.</p>

<p><a name="coda.Type.has_attributes"></a></p>

<h4>has_attributes</h4>

<p><code>python
 | @property
 | has_attributes()
</code></p>

<p>Return a boolean indicating whether the type has any
attributes.</p>

<p><a name="coda.Type.attributes"></a></p>

<h4>attributes</h4>

<p><code>python
 | @property
 | attributes()
</code></p>

<p>Return the type for the associated attribute record.</p>

<p><a name="coda.Type.read_type"></a></p>

<h4>read_type</h4>

<p><code>python
 | @property
 | read_type()
</code></p>

<p>Return the best native type for reading the data.</p>

<p><a name="coda.Type.unit"></a></p>

<h4>unit</h4>

<p><code>python
 | @property
 | unit()
</code></p>

<p>Return the type unit.</p>

<p><a name="coda.Type.bit_size"></a></p>

<h4>bit_size</h4>

<p><code>python
 | @property
 | bit_size()
</code></p>

<p>Return the bit size for the type.</p>

<p><a name="coda.Type.fixed_value"></a></p>

<h4>fixed_value</h4>

<p><code>python
 | @property
 | fixed_value()
</code></p>

<p>Return the associated fixed value string for the type.</p>

<p><a name="coda.IntegerType"></a></p>

<h2>IntegerType Objects</h2>

<p><code>python
class IntegerType(Type)
</code></p>

<p>CODA Integer Type class.</p>

<p><a name="coda.RealType"></a></p>

<h2>RealType Objects</h2>

<p><code>python
class RealType(Type)
</code></p>

<p>CODA Real Type class.</p>

<p><a name="coda.RecordType"></a></p>

<h2>RecordType Objects</h2>

<p><code>python
class RecordType(Type)
</code></p>

<p>CODA Record Type class.</p>

<p>Unions are implemented in CODA as records where only one field is
'available' a ta time.</p>

<p><a name="coda.RecordType.num_fields"></a></p>

<h4>num_fields</h4>

<p><code>python
 | @property
 | num_fields()
</code></p>

<p>Return the total number of fields.</p>

<p><a name="coda.RecordType.field_hidden_status"></a></p>

<h4>field_hidden_status</h4>

<p><code>python
 | field_hidden_status(index)
</code></p>

<p>Return a boolean indicating whether a field is hidden.</p>

<p><strong>Arguments</strong>:</p>

<ul>
<li><code>index</code> - record field index</li>
</ul>

<p><a name="coda.RecordType.field_available_status"></a></p>

<h4>field_available_status</h4>

<p><code>python
 | field_available_status(index)
</code></p>

<p>Return a boolean indicating whether a field is available.</p>

<p><strong>Arguments</strong>:</p>

<ul>
<li><code>index</code> - record field index</li>
</ul>

<p><a name="coda.RecordType.field_type"></a></p>

<h4>field_type</h4>

<p><code>python
 | field_type(index)
</code></p>

<p>Return 'Type' instance corresponding to a field.</p>

<p><strong>Arguments</strong>:</p>

<ul>
<li><code>index</code> - record field index</li>
</ul>

<p><a name="coda.RecordType.field_name"></a></p>

<h4>field_name</h4>

<p><code>python
 | field_name(index)
</code></p>

<p>Return the name of a field.</p>

<p><strong>Arguments</strong>:</p>

<ul>
<li><code>index</code> - record field index</li>
</ul>

<p><a name="coda.RecordType.field_real_name"></a></p>

<h4>field_real_name</h4>

<p><code>python
 | field_real_name(index)
</code></p>

<p>Return the real (unaltered) name of a field.</p>

<p>Regular field names may be altered because of restrictions on identifier naming.</p>

<p><strong>Arguments</strong>:</p>

<ul>
<li><code>index</code> - record field index</li>
</ul>

<p><a name="coda.RecordType.field_index_from_name"></a></p>

<h4>field_index_from_name</h4>

<p><code>python
 | field_index_from_name(name)
</code></p>

<p>Return the index of a field with given name.</p>

<p><strong>Arguments</strong>:</p>

<ul>
<li><code>index</code> - record field name</li>
</ul>

<p><a name="coda.RecordType.field_index_from_real_name"></a></p>

<h4>field_index_from_real_name</h4>

<p><code>python
 | field_index_from_real_name(name)
</code></p>

<p>Return the name of a field with given index.</p>

<p><strong>Arguments</strong>:</p>

<ul>
<li><code>index</code> - record field index</li>
</ul>

<p><a name="coda.RecordType.union_status"></a></p>

<h4>union_status</h4>

<p><code>python
 | @property
 | union_status()
</code></p>

<p>Return a boolean indicating whether the record is a union.</p>

<p><a name="coda.ArrayType"></a></p>

<h2>ArrayType Objects</h2>

<p><code>python
class ArrayType(Type)
</code></p>

<p>CODA Array Type class.</p>

<p><a name="coda.ArrayType.base_type"></a></p>

<h4>base_type</h4>

<p><code>python
 | @property
 | base_type()
</code></p>

<p>Return a 'Type' instance corresponding to the array elements.</p>

<p><a name="coda.ArrayType.dim"></a></p>

<h4>dim</h4>

<p><code>python
 | @property
 | dim()
</code></p>

<p>Return a list with array dimension sizes.</p>

<p>The size of a variable dimension is represented as -1.</p>

<p><a name="coda.SpecialType"></a></p>

<h2>SpecialType Objects</h2>

<p><code>python
class SpecialType(Type)
</code></p>

<p>CODA Special Type class.</p>

<p><a name="coda.SpecialType.base_type"></a></p>

<h4>base_type</h4>

<p><code>python
 | @property
 | base_type()
</code></p>

<p>Return a 'Type' instance corresponding to the special type
base type.</p>

<p><a name="coda.TextType"></a></p>

<h2>TextType Objects</h2>

<p><code>python
class TextType(Type)
</code></p>

<p>CODA Text Type class.</p>

<p><a name="coda.TextType.string_length"></a></p>

<h4>string_length</h4>

<p><code>python
 | @property
 | string_length()
</code></p>

<p>Return the string length in bytes.</p>

<p><a name="coda.RawType"></a></p>

<h2>RawType Objects</h2>

<p><code>python
class RawType(Type)
</code></p>

<p>CODA Raw Type class.</p>

<p><a name="coda.Expression"></a></p>

<h2>Expression Objects</h2>

<p><code>python
class Expression(object)
</code></p>

<p>CODA Expression class.</p>

<p>An instance of this class represents a CODA expression.</p>

<p>It is a wrapper class around the low-level coda_expression struct.</p>

<p>Consult the CODA documentation for information about the the CODA
expression language.</p>

<p><a name="coda.Expression.__init__"></a></p>

<h4>__init__</h4>

<p><code>python
 | __init__(s)
</code></p>

<p>Initialize an 'Expression' instance.</p>

<p>The instance should be cleaned up after use via 'with' keyword or
by calling the 'delete' method.</p>

<p><strong>Arguments</strong>:</p>

<ul>
<li><code>s</code> - string containing CODA expression</li>
</ul>

<p><a name="coda.Expression.is_constant"></a></p>

<h4>is_constant</h4>

<p><code>python
 | is_constant()
</code></p>

<p>Return a boolean indicating whether the expression is constant.</p>

<p>An expression is constant if it does not depend on the contents of
a product and hence can be evaluated without requiring a cursor.</p>

<p><a name="coda.Expression.is_equal"></a></p>

<h4>is_equal</h4>

<p><code>python
 | is_equal(expr)
</code></p>

<p>Return a boolean indicating whether the expression is equal
to another 'Expression' instance.</p>

<p>For two expressions to be considered as equal, all operands to an
operation need to be equal and operands need to be provided in the
same order.</p>

<p>For example, the expression '1!=2' is not considered equal to the
expression '2!=1'.</p>

<p><strong>Arguments</strong>:</p>

<ul>
<li><code>expr</code> - 'Expression' instance</li>
</ul>

<p><a name="coda.Expression.eval"></a></p>

<h4>eval</h4>

<p><code>python
 | eval(cursor=None)
</code></p>

<p>Evaluate the expression and return the resulting value.</p>

<p>For a constant expression, the 'cursor' argument is optional.</p>

<p>For a node expression, the cursor is moved to the resulting
location and no value is returned.</p>

<p><strong>Arguments</strong>:</p>

<ul>
<li><code>cursor</code> - 'Cursor' instance (optional)</li>
</ul>

<p><a name="coda.Expression.expression_type"></a></p>

<h4>expression_type</h4>

<p><code>python
 | @property
 | expression_type()
</code></p>

<p>Return the name of the expression type.</p>

<p><a name="coda.Expression.delete"></a></p>

<h4>delete</h4>

<p><code>python
 | delete()
</code></p>

<p>Delete the low-level CODA expression object.</p>

<p>Note that it is also possible to use the 'with' keyword for this.</p>

      <h2 id="high_level_functions">High level CODA Functions</h2>
      
      <a id="coda_path_argument"></a><p>Most high level CODA functions require a <code>start</code> and <code>path</code> parameter. These two parameters together define the location of a data item in a product.</p>

      <p>The <code>start</code> parameter determines the offset in the product from which the <code>path</code> parameter is expanded. It can either be a file handle or a CODA Cursor (see <a href="#low_level_types">Low level CODA Data Types</a>). When a file handle is passed we start at the root of the product and when it is a cursor we start at the position of the cursor.</p>

      <p>The <code>path</code> argument is actually a series of parameters (which can also be empty). Starting from the <code>start</code> position, the <code>path</code> parameters should provide valid fieldnames and array indices to navigate deeper into the product. For example, suppose we have a product that has a <code>measurements</code> data set with 100 data set records and in each data set record there is a <code>time</code> field containing a time value of type double. If we want to read the time value in the first data set record (using the file handle <code>filehandle</code> as <code>start</code> parameter) we would use: <code>coda.fetch(filehandle, "measurements", 0, "time")</code>. You can provide each path argument as a separate parameter or combine them together into a single string argument. Alternative calls that have the same result could thus be <code>coda.fetch(filehandle, "measurements[0]", "time")</code> or <code>coda.fetch(filehandle, "measurements[0]/time")</code>.</p>

      <p>It is also possible to read several data elements at once. We can for instance read the full data set record using <code>coda.fetch(filehandle, "measurements", 0)</code> or even read the whole product using <code>coda.fetch(filehandle)</code>. When you read a group of data at once, CODA will create a dynamic data structure in Python (consisting of <code>coda.Record</code> and <code>numpy.array</code> objects to represent records and arrays) for the product data that is read.</p>

      <p>The types of arguments that you can use in the list of arguments for <code>path</code> are:</p>
      <ul>
        <li>Array index: You need to provide an array index that has the same number of elements as there are dimensions in the array that you are referring to. So if the array is two dimensional you have to pass indices for both dimensions like <code>[4,5]</code>. If the array is one dimensional you can just provide a single index value (without the '[]') to get to the k-th element. You can use <a href="#coda_get_size"><code>coda.get_size</code></a> to check the number of dimensions of an array and the size of each dimension.</li>
        <li>Field name: To go to a certain field inside the record that you are pointing to, just provide the field name as a string. You should be aware that some record fields can be dynamically available. In such cases it is better to check in advance (using <a href="#coda_get_field_available"><code>coda.get_field_available</code></a>) whether the field is available, before traversing it.</li>
        <li>Path: You can provide a string containing a path reference, such as <code>"measurements[0]/time"</code>. Using paths will also allow you to navigate to attributes by using <code>"@"</code> as a path component. For instance, '<code>"temperature", "@", "units"</code>' or <code>"temperature@units"</code> will point to the units attribute of the temperature data. Note that array indices used in these string paths need to be 0-based indices on the flattened view of an array. This means that if an array is defined as having more than one dimension then the index as used in a path expression should be between 0 and the total number of array elements (exclusive). For example, for a [10,8] array, the index should be >= 0 and <= 79.</li>
      </ul>

      <p>Just as the low level functions, the high level CODA Python functions will throw an exception when an error condition occurs. For the high level functions the exception will be of type <code>coda.CodaError</code>.</p>

      <h3 id="coda_open_hl"><code>coda.open(filename)</code></h3>

      <p>This function opens a file and returns a handle to the opened product file.</p>

      <p>The high and lowel level <code>coda.open</code> functions are actually one and the same. You can thus use the product file handle that is returned by <code>coda.open</code> both as <code>start</code> parameter in the high level CODA functions mentioned below as well as <code>pf</code> parameter in the <a href="#low_level_functions">low level CODA functions</a>.</p>

      <h3 id="coda_open_as_hl"><code>coda.open_as(filename, product_class, product_type, version)</code></h3>

      <p>This function will try to open the specified file for reading similar to <code>coda.open</code>, but instead of trying to automatically recognise the applicable product class/type/version as <code>coda.open</code> does, this function will impose the format definition that is associated with the given product_class, product_type, and version parameters.</p>

      <p>Note that you normally won't need this function as CODA will be able to recognize which format definition to use automatically. However, for the rare occasions where <code>coda.open</code> is not sufficient, you can use this function to force the use of a specific format definition.</p>

      <p>You can specify -1 for the version to request the latest available version of the format definition.</p>

      <p>The high and lowel level <code>coda.open_as</code> functions are one and the same, just as for <code>coda.open</code>.</p>

      <h3 id="coda_close_hl"><code>coda.close(filehandle)</code></h3>
      
      <p>This function closes the file associated with the file handle <code>filehandle</code>.</p>

      <p>Just as the <code>coda.open</code> function, the high and lowel level <code>coda.close</code> functions are one and the same.</p>

      <h3 id="coda_get_attributes"><code>coda.get_attributes(start, *path)</code></h3>

      <p>Retrieve the attributes of the specified data item.</p>
    
      <p>This function returns a <a href="#high_level_types"><code>coda.Record</code></a> containing the attributes of the specified data item.</p>
    
      <p>The <code>start</code> parameter must be a valid CODA file handle that was retrieved with <code>coda.open()</code> <i>or</i> a valid <a href="#low_level_types">CODA Cursor</a>. If the start argument is a cursor, then the specified path is traversed starting from the position represented by the cursor. The format of the <code>path</code> argument is described at the <a href="#coda_path_argument">top of this section</a>.</p>

      <p>This function is deprecated. You can replace it by using <code>coda.fetch(start, *path, "@")</code>.</p>

      <h3 id="coda_get_description"><code>coda.get_description(start, *path)</code></h3>

      <p>Retrieve the description of a field.</p>

      <p>This function returns a string containing the description in the CODA product format definition of the specified data element.</p>

      <p>The <code>start</code> parameter must be a valid CODA file handle that was retrieved with <code>coda.open()</code> <i>or</i> a valid <a href="#low_level_types">CODA Cursor</a>. If the start argument is a cursor, then the specified path is traversed starting from the position represented by the cursor. The format of the <code>path</code> argument is described at the <a href="#coda_path_argument">top of this section</a>.</p>

      <h3 id="coda_fetch"><code>coda.fetch(start, *path)</code></h3>
      
      <p>Retrieve data from a product file.</p>
    
      <p>Reads the specified data element from the product file. For instance if <code>pf</code> is a product file handle obtained by calling <code>coda.open()</code> and the product contains a dataset of records then you can retrieve a time field from the first record using:</p>

<div class="fragment"><pre>
>>> value = coda.fetch(pf, "datasetname", 0, "time")
</pre></div>

      <p>You can also combine the path into a single string parameter:</p>

<div class="fragment"><pre>
>>> value = coda.fetch(pf, "datasetname[0]/time")
</pre></div>

      <p>Which path to provide depends on the format of the product you are trying to access.</p>

      <p>Instead of just reading individual values, like strings, integers, doubles, etc. it is also possible to read complete arrays or records of data. For instance, you could read the whole first record of the dataset using:</p>

<div class="fragment"><pre>
>>> record = coda.fetch(pf, "datasetname", 0)
</pre></div>

      <p>This gives you a <a href="#high_level_types"><code>coda.Record</code></a> containing all the record fields.</p>

      <p>It is also possible to read an entire product at once by leaving the data specification argument list empty:</p>

<div class="fragment"><pre>
>>> product = coda.fetch(pf)
</pre></div>

      <p>To read attributes, you can pass '@' as path element. For instance, the following command reads the 'units' attribute value from a temperature variable:</p>

<div class="fragment"><pre>
>>> unit = coda.fetch(pf, "temperature@units")
</pre></div>

      <p>For the <code>coda.fetch</code> function there is an additional feature. If you provide a -1 for one or more of the dimensions of an array you will fetch all elements in the specified dimension(s). For example, with <code>coda.fetch(pf, "datasetname", -1, "dsr_time")</code> you can fetch all <code>dsr_time</code> values for all measurements into a single array. Note that passing -1 only works when passing it as an explicit argument (i.e. calling <code>coda.fetch(pf, "dataset[-1]/dsr_time")</code>, where the -1 index is part of a string argument, will not work).</p>

      <p>The <code>start</code> parameter must be a valid CODA file handle that was retrieved with <code>coda.open()</code> <i>or</i> a valid <a href="#low_level_types">CODA Cursor</a>. If the start argument is a cursor, then the specified path is traversed starting from the position represented by the cursor. The format of the <code>path</code> argument is described at the <a href="#coda_path_argument">top of this section</a>.</p>

      <h3 id="coda_get_field_available"><code>coda.get_field_available(start, *path)</code></h3>

      <p>Find out whether a dynamically available record field is available or not.</p>
    
      <p>This function returns True if the record field is available and False if it is not. The last item of the <code>path</code> argument should point to a record field. An empty <code>path</code> is considered an error, even if the start argument is a CODA cursor.</p>

      <p>The <code>start</code> parameter must be a valid CODA file handle that was retrieved with <code>coda.open()</code> <i>or</i> a valid <a href="#low_level_types">CODA Cursor</a>. If the start argument is a cursor, then the specified path is traversed starting from the position represented by the cursor. The format of the <code>path</code> argument is described at the <a href="#coda_path_argument">top of this section</a>.</p>

      <h3 id="coda_get_field_count"><code>coda.get_field_count(start, *path)</code></h3>

      <p>Retrieve the number of fields in a record.</p>

      <p>This function returns the number of fields in the <a href="#high_level_types"><code>coda.Record</code></a> instance that will be returned if <code>coda.fetch()</code> is called with the same arguments. The last node on the path should reference a record.</p>

      <p>The <code>start</code> parameter must be a valid CODA file handle that was retrieved with <code>coda.open()</code> <i>or</i> a valid <a href="#low_level_types">CODA Cursor</a>. If the start argument is a cursor, then the specified path is traversed starting from the position represented by the cursor. The format of the <code>path</code> argument is described at the <a href="#coda_path_argument">top of this section</a>.</p>

      <h3 id="coda_get_field_names"><code>coda.get_field_names(start, *path)</code></h3>

      <p>Retrieve the names of the fields in a record.</p>

      <p>This function returns the names of the fields in the <a href="#high_level_types"><code>coda.Record</code></a> instance that will be returned if <code>coda.fetch()</code> is called with the same arguments. The last node on the path should reference a record.</p>

      <p>The <code>start</code> parameter must be a valid CODA file handle that was retrieved with <code>coda.open()</code> <i>or</i> a valid <a href="#low_level_types">CODA Cursor</a>. If the start argument is a cursor, then the specified path is traversed starting from the position represented by the cursor. The format of the <code>path</code> argument is described at the <a href="#coda_path_argument">top of this section</a>.</p>

      <h3 id="coda_get_size"><code>coda.get_size(start, *path)</code></h3>

      <p>Retrieve the dimensions of the specified array.</p>

      <p>This function returns the dimensions of the array that will be returned if <code>coda.fetch()</code> is called with the same arguments. Thus, you can check what the dimensions of an array are without having to retrieve the entire array with <code>coda.fetch()</code>. The last node on the path should reference an array.</p>

      <p>The <code>start</code> parameter must be a valid CODA file handle that was retrieved with <code>coda.open()</code> <i>or</i> a valid <a href="#low_level_types">CODA Cursor</a>. If the start argument is a cursor, then the specified path is traversed starting from the position represented by the cursor. The format of the <code>path</code> argument is described at the <a href="#coda_path_argument">top of this section</a>.</p>

      <h3 id="coda_time_to_string"><code>coda.time_to_string(n_seconds_since_2000)</code></h3>

      <p>Convert a number of seconds since 2000-01-01 to a human readable string format. For example:</p>

<div class="fragment"><pre>
>>> coda.time_to_string(68260079.0)
</pre></div>

      <p>would return the string <code>'2002-03-01 01:07:59.000000'</code>.</p>

      <p>It is possible to input a list or tuple of doubles, in which case a list of strings will be returned.</p>

      <h3 id="coda_time_to_utcstring"><code>coda.time_to_utcstring(n_seconds_since_2000)</code></h3>

      <p>Convert a TAI number of seconds since 2000-01-01 (TAI) to a human readable string format in UTC format. For example:</p>

<div class="fragment"><pre>
>>> coda.time_to_utcstring(68260111.0)
</pre></div>

      <p>would return the string <code>'2002-03-01 01:07:59.000000'</code>.</p>

      <p>It is possible to input a list or tuple of doubles, in which case a list of strings will be returned.</p>

      <h3 id="coda_get_unit"><code>coda.get_unit(start, *path)</code></h3>

      <p>Retrieve unit information.</p>

      <p>This function returns a string containing the unit information which is stored in the CODA product format definition for the specified data item.</p>

      <p>The <code>start</code> parameter must be a valid CODA file handle that was retrieved with <code>coda.open()</code> <i>or</i> a valid <a href="#low_level_types">CODA Cursor</a>. If the start argument is a cursor, then the specified path is traversed starting from the position represented by the cursor. The format of the <code>path</code> argument is described at the <a href="#coda_path_argument">top of this section</a>.</p>

      <h3 id="coda_version"><code>coda.version()</code></h3>

      <p>Retrieve CODA version information.</p>

      <p>This function returns a string containing the version number of CODA. The version number is always of the format 'x.y.z', i.e., major, minor, and revision numbers, separated by dots.</p>

      <h3 id="coda_set_option_filter_record_fields"><code>coda.set_option_filter_record_fields(enable)</code></h3>

      <p>Records like for instance a Main Product Header contain fields that have a fixed value (fieldnames like 'PRODUCT=', quote characters, end of line characters, etc.) or are spare fields. If this option is set to 1 then these kinds of fields will be filtered out when retrieving a record from a product file (using e.g. <code>coda.fetch</code>). If this option is set to 0 then all fields will be returned.</p>

      <p>The default value for this option is: 1</p>
      
      <p>This option only effects the higher level CODA Python functions. The lower level functions do not perform filtering on record fields.</p>

      <h3 id="coda_get_option_filter_record_fields "><code>coda.get_option_filter_record_fields()</code></h3>

      <p>Retrieve the current setting for filtering of record fields.</p>
      
      <p>See also <a href="#coda_set_option_filter_record_fields"><code>coda.set_option_filter_record_fields(enable)</code></a>.</p>

      <h2 id="low_level_types">Low level CODA Data Types</h2>
      
      <p>Just as in the C interface the <code>coda_product</code>, <code>coda_type</code>, and <code>coda_cursor</code> types are opaque types. This means that you can not print or inspect these types, but can only pass them around.</p>

      <p>To create a new CODA Cursor there is a special <code>coda.Cursor</code> class from which you instantiate new Cursor objects (these objects are opaque wrappers of the underlying cursors in the C domain). You can create a new cursors with: <code>cursor = coda.Cursor()</code>. After creation you will have to initialize it using the <code>coda.cursor_set_product</code> function (just like in C). It is possible to create a copy of a CODA Cursor by using a so-called deep copy:</p>

<div class="fragment"><pre>
import copy
cursor = coda.Cursor()
cursor2 = copy.deepcopy(cursor)
</pre></div>

      <h2 id="low_level_functions">Low level CODA Functions</h2>
      
      <p>For a description of all low level CODA functions please consult the <a href="../libcoda/index.html">CODA C interface documentation</a>. There are a few differences between the Python and C interface with respect to certain parameters and error handling. Below you will find an overview of the calling signature for each of the supported low level CODA functions. You'll notice that most differences are rather straightforward (parameters have moved from the parameter list to the list of return values or have been removed). If a change requires more explanation a comment is added to the function definition.</p>

      <a id="error_handling"></a><p>The low level CODA Python functions do not return error codes to indicate succes or failure (as is the case for the C functions). If an error condition occurs, an exception (of type <code>coda.CodacError</code>) will be thrown. You can catch this exception using e.g.:</p>

<div class="fragment"><pre>
try:
    # call your CODA function(s) here
except coda.CodacError, e:
    # handle CODA-specific exception
    print "ERROR: %s" % e
</pre></div>

      <p>If you do not catch the exception, the error message will be printed to the console.</p>

      <h5 id="coda_init"><code>coda.init()</code></h5>
      <p>You do not have to call this function yourself to initialize CODA. When CODA is imported in Python the <code>init</code> function will already be called for you. If, however, you call <code>coda.done</code> at any time, you can use this function to re-initialize CODA again.</p>
      <p>Note that the <code>coda_set_definition_path</code> function is not provided in the CODA Python interface. You should use the CODA_DEFINITION environment variable to set the definition path as explained in the <a href="#codadef">CODA Definition Path</a> section.</p>
      <h5 id="coda_done"><code>coda.done()</code></h5>
      <p>If, for some reason, you want to unload the CODA package, you should first clean up CODA by calling this function. However, unloading a Python package is not a common activity, so you should rarely have to call <code>coda.done()</code>.</p>
      <h5 id="coda_set_option_bypass_special_types"><code>coda.set_option_bypass_special_types(enable)</code></h5>
      <h5 id="coda_get_option_bypass_special_types"><code>coda.get_option_bypass_special_types()</code></h5>
      <h5 id="coda_set_option_perform_boundary_checks"><code>coda.set_option_perform_boundary_checks(enable)</code></h5>
      <h5 id="coda_get_option_perform_boundary_checks"><code>coda.get_option_perform_boundary_checks()</code></h5>
      <h5 id="coda_set_option_perform_conversions"><code>coda.set_option_perform_conversions(enable)</code></h5>
      <h5 id="coda_get_option_perform_conversions"><code>coda.get_option_perform_conversions()</code></h5>
      <h5 id="coda_set_option_use_fast_size_expressions"><code>coda.set_option_use_fast_size_expressions(enable)</code></h5>
      <h5 id="coda_get_option_use_fast_size_expressions"><code>coda.get_option_use_fast_size_expressions()</code></h5>
      <h5 id="coda_set_option_use_mmap"><code>coda.set_option_use_mmap(enable)</code></h5>
      <h5 id="coda_get_option_use_mmap"><code>coda.get_option_use_mmap()</code></h5>
      <h5 id="coda_NaN"><code>coda.NaN()</code></h5>
      <h5 id="coda_isNaN"><code>coda.isNaN(x)</code></h5>
      <h5 id="coda_PlusInf"><code>coda.PlusInf()</code></h5>
      <h5 id="coda_MinInf"><code>coda.MinInf()</code></h5>
      <h5 id="coda_isInf"><code>coda.isInf(x)</code></h5>
      <h5 id="coda_isPlusInf"><code>coda.isPlusInf(x)</code></h5>
      <h5 id="coda_isMinInf"><code>coda.isMinInf(x)</code></h5>
      <h5 id="coda_c_index_to_fortran_index"><code>coda.c_index_to_fortran_index(num_dims, dim, index)</code></h5>
      <h5 id="coda_match_filefilter"><code>coda.match_filefilter(filter, filepaths, callbackfunc)</code></h5>
      <p>The <code>callbackfunc</code> parameter should be a Python function that accepts <code>filepath</code>, <code>status</code> and <code>error</code> as parameters. For example:</p>
<div class="fragment"><pre>
>>> def findhelper(filepath, status, error):
...     if status == coda.coda_ffs_match:
...         print "File %s matches filter!" % filepath    
...     elif ((status == coda.coda_ffs_unsupported_file)
...         or (status == coda.coda_ffs_no_match)):
...         # don't print anything if the file does not positively match the filter
...         pass
...     else:
...         print "ERROR: %s (%s)" % (error, filepath)
...     return 0
>>> coda.match_filefilter('', '/home/codauser', findhelper)
</pre></div>
      <h5 id="coda_time_double_to_parts"><code>[YEAR, MONTH, DAY, HOUR, MINUTE, SECOND, MUSEC] = coda.time_double_to_parts(datetime)</code></h5>
      <h5 id="coda_time_double_to_parts_utc"><code>[YEAR, MONTH, DAY, HOUR, MINUTE, SECOND, MUSEC] = coda.time_double_to_parts_utc(datetime)</code></h5>
      <h5 id="coda_time_parts_to_double"><code>datetime = coda.time_parts_to_double(YEAR, MONTH, DAY, HOUR, MINUTE, SECOND, MUSEC)</code></h5>
      <h5 id="coda_time_parts_to_double_utc"><code>datetime = coda.time_parts_to_double_utc(YEAR, MONTH, DAY, HOUR, MINUTE, SECOND, MUSEC)</code></h5>
      <h5 id="coda_time_parts_to_string"><code>str = coda.time_parts_to_string(YEAR, MONTH, DAY, HOUR, MINUTE, SECOND, MUSEC, format)</code></h5>
      <h5 id="coda_time_string_to_parts"><code>[YEAR, MONTH, DAY, HOUR, MINUTE, SECOND, MUSEC] = coda.time_string_to_parts(format, str)</code></h5>
      <h5 id="coda_time_double_to_string"><code>str = coda.time_double_to_string(datetime, format)</code></h5>
      <h5 id="coda_time_double_to_string_utc"><code>str = coda.time_double_to_string_utc(datetime, format)</code></h5>
      <h5 id="coda_time_string_to_double"><code>datetime = coda.time_string_to_double(format, str)</code></h5>
      <h5 id="coda_time_string_to_double_utc"><code>datetime = coda.time_string_to_double_utc(format, str)</code></h5>
      <h5 id="coda_recognize_file"><code>[file_size, format, product_class, product_type, version] = coda.recognize_file(filename)</code></h5>
      <h5 id="coda_open"><code>pf = coda.open(filename)</code></h5>
      <p>The product file handle returned by this function can also be used with the <a href="#high_level_functions">high level CODA functions</a>.</p>
      <h5 id="coda_open_as"><code>pf = coda.open_as(filename, product_class, product_type, version)</code></h5>
      <h5 id="coda_close"><code>coda.close(pf)</code></h5>
      <h5 id="coda_get_product_filename"><code>filename = coda.get_product_filename(pf)</code></h5>
      <h5 id="coda_get_product_file_size"><code>file_size = coda.get_product_file_size(pf)</code></h5>
      <h5 id="coda_get_product_format"><code>format = coda.get_product_format(pf)</code></h5>
      <h5 id="coda_get_product_class"><code>product_class = coda.get_product_class(pf)</code></h5>
      <h5 id="coda_get_product_type"><code>product_type = coda.get_product_type(pf)</code></h5>
      <h5 id="coda_get_product_version"><code>version = coda.get_product_version(pf)</code></h5>
      <h5 id="coda_get_product_root_type"><code>type = coda.get_product_root_type(pf)</code></h5>
      <h5 id="coda_get_product_backend"><code>backend = coda.get_product_backend(pf)</code></h5>
      <h5 id="coda_get_product_variable_value"><code>value = coda.get_product_variable_value(pf, variable, index)</code></h5>
      <h5 id="coda_type_get_format_name"><code>coda.type_get_format_name(type_class)</code></h5>
      <h5 id="coda_type_get_class_name"><code>coda.type_get_class_name(type_class)</code></h5>
      <h5 id="coda_type_get_native_type_name"><code>coda.type_get_native_type_name(native_type)</code></h5>
      <h5 id="coda_type_get_special_type_name"><code>coda.type_get_special_type_name(special_type)</code></h5>
      <h5 id="coda_type_has_attributes"><code>has_attributes = coda.type_has_attributes(type)</code></h5>
      <h5 id="coda_type_get_format"><code>format = coda.type_get_format(type)</code></h5>
      <h5 id="coda_type_get_class"><code>type_class = coda.type_get_class(type)</code></h5>
      <h5 id="coda_type_get_read_type"><code>read_type = coda.type_get_read_type(type)</code></h5>
      <h5 id="coda_type_get_string_length"><code>length = coda.type_get_string_length(type)</code></h5>
      <h5 id="coda_type_get_bit_size"><code>bit_size = coda.type_get_bit_size(type)</code></h5>
      <h5 id="coda_type_get_name"><code>name = coda.type_get_name(type)</code></h5>
      <h5 id="coda_type_get_description"><code>description = coda.type_get_description(type)</code></h5>
      <h5 id="coda_type_get_unit"><code>unit = coda.type_get_unit(type)</code></h5>
      <h5 id="coda_type_get_fixed_value"><code>fixed_value = coda.type_get_fixed_value(type)</code></h5>
      <h5 id="coda_type_get_attributes"><code>attributes = coda.type_get_attributes(type)</code></h5>
      <h5 id="coda_type_get_num_record_fields"><code>num_fields = coda.type_get_num_record_fields(type)</code></h5>
      <h5 id="coda_type_get_record_field_index_from_name"><code>index = coda.type_get_record_field_index_from_name(type, name)</code></h5>
      <h5 id="coda_type_get_record_field_index_from_real_name"><code>index = coda.type_get_record_field_index_from_real_name(type, real_name)</code></h5>
      <h5 id="coda_type_get_record_field_type"><code>field_type = coda.type_get_record_field_type(type, index)</code></h5>
      <h5 id="coda_type_get_record_field_name"><code>name = coda.type_get_record_field_name(type, index)</code></h5>
      <h5 id="coda_type_get_record_field_real_name"><code>name = coda.type_get_record_field_real_name(type, index)</code></h5>
      <h5 id="coda_type_get_record_field_hidden_status"><code>hidden = coda.type_get_record_field_hidden_status(type, index)</code></h5>
      <h5 id="coda_type_get_record_field_available_status"><code>available = coda.type_get_record_field_available_status(type, index)</code></h5>
      <h5 id="coda_type_get_record_union_status"><code>is_union = coda.type_get_record_union_status(type)</code></h5>
      <h5 id="coda_type_get_array_num_dims"><code>num_dims = coda.type_get_array_num_dims(type)</code></h5>
      <h5 id="coda_type_get_array_dim"><code>dim = coda.type_get_array_dim(type)</code></h5>
      <h5 id="coda_type_get_array_base_type"><code>base_type = coda.type_get_array_base_type(type)</code></h5>
      <h5 id="coda_type_get_special_type"><code>special_type = coda.type_get_special_type(type)</code></h5>
      <h5 id="coda_type_get_special_base_type"><code>base_type = coda.type_get_special_base_type(type)</code></h5>
      <h5 id="coda_cursor_set_product"><code>coda.cursor_set_product(cursor, product)</code></h5>
      <p>You can create a new cursor with <code>cursor = coda.Cursor()</code>. With <code>coda.cursor_set_product</code> this cursor can then be initialized to the root of a product. It is also possible to use a cursor as <code>start</code> parameter in the <a href="#high_level_functions">high level CODA functions</a>.</p>
      <h5 id="coda_cursor_goto"><code>coda.cursor_goto(cursor, path)</code></h5>
      <h5 id="coda_cursor_goto_first_record_field"><code>coda.cursor_goto_first_record_field(cursor)</code></h5>
      <h5 id="coda_cursor_goto_next_record_field"><code>coda.cursor_goto_next_record_field(cursor)</code></h5>
      <h5 id="coda_cursor_goto_record_field_by_index"><code>coda.cursor_goto_record_field_by_index(cursor, index)</code></h5>
      <h5 id="coda_cursor_goto_record_field_by_name"><code>coda.cursor_goto_record_field_by_name(cursor, name)</code></h5>
      <h5 id="coda_cursor_goto_available_union_field"><code>coda.cursor_goto_available_union_field(cursor)</code></h5>
      <h5 id="coda_cursor_goto_first_array_element"><code>coda.cursor_goto_first_array_element(cursor)</code></h5>
      <h5 id="coda_cursor_goto_next_array_element"><code>coda.cursor_goto_next_array_element(cursor)</code></h5>
      <h5 id="coda_cursor_goto_array_element"><code>coda.cursor_goto_array_element(cursor, subs)</code></h5>
      <p>It is not needed to provide the number of dimensions as a parameter (<code>num_subs</code>) since this value is determined from inspecting the length of <code>subs</code>.</p>
      <h5 id="coda_cursor_goto_array_element_by_index"><code>coda.cursor_goto_array_element_by_index(cursor, index)</code></h5>
      <h5 id="coda_cursor_goto_attributes"><code>coda.cursor_goto_attributes(cursor)</code></h5>
      <h5 id="coda_cursor_goto_root"><code>coda.cursor_goto_root(cursor)</code></h5>
      <h5 id="coda_cursor_goto_parent"><code>coda.cursor_goto_parent(cursor)</code></h5>
      <h5 id="coda_cursor_use_base_type_of_special_type"><code>coda.cursor_use_base_type_of_special_type(cursor)</code></h5>
      <h5 id="coda_cursor_has_ascii_content"><code>has_ascii_content = coda.cursor_has_ascii_content(cursor)</code></h5>
      <h5 id="coda_cursor_has_attributes"><code>has_attributes = coda.cursor_has_attributes(cursor)</code></h5>
      <h5 id="coda_cursor_get_string_length"><code>length = coda.cursor_get_string_length(cursor)</code></h5>
      <h5 id="coda_cursor_get_bit_size"><code>bit_size = coda.cursor_get_bit_size(cursor)</code></h5>
      <h5 id="coda_cursor_get_byte_size"><code>byte_size = coda.cursor_get_byte_size(cursor)</code></h5>
      <h5 id="coda_cursor_get_num_elements"><code>num_elements = coda.cursor_get_num_elements(cursor)</code></h5>
      <h5 id="coda_cursor_get_product_file"><code>pf = coda.cursor_get_product_file(cursor)</code></h5>
      <h5 id="coda_cursor_get_depth"><code>depth = coda.cursor_get_depth(cursor)</code></h5>
      <h5 id="coda_cursor_get_index"><code>index = coda.cursor_get_index(cursor)</code></h5>
      <h5 id="coda_cursor_get_file_bit_offset"><code>bit_offset = coda.cursor_get_file_bit_offset(cursor)</code></h5>
      <h5 id="coda_cursor_get_file_byte_offset"><code>byte_offset = coda.cursor_get_file_byte_offset(cursor)</code></h5>
      <h5 id="coda_cursor_get_format"><code>format = coda.cursor_get_format(cursor)</code></h5>
      <h5 id="coda_cursor_get_type_class"><code>type_class = coda.cursor_get_type_class(cursor)</code></h5>
      <h5 id="coda_cursor_get_read_type"><code>read_type = coda.cursor_get_read_type(cursor)</code></h5>
      <h5 id="coda_cursor_get_special_type"><code>special_type = coda.cursor_get_special_type(cursor)</code></h5>
      <h5 id="coda_cursor_get_type"><code>type = coda.cursor_get_type(cursor)</code></h5>
      <h5 id="coda_cursor_get_record_field_index_from_name"><code>index = coda.cursor_get_record_field_index_from_name(cursor, name)</code></h5>
      <h5 id="coda_cursor_get_record_field_available_status"><code>available = coda.cursor_get_record_field_available_status(cursor, index)</code></h5>
      <h5 id="coda_cursor_get_available_union_field_index"><code>index = coda.cursor_get_available_union_field_index(cursor)</code></h5>
      <h5 id="coda_cursor_get_array_dim"><code>dim = coda.cursor_get_array_dim(cursor)</code></h5>
      <h5 id="coda_cursor_read_int8"><code>dst = coda.cursor_read_int8(cursor)</code></h5>
      <h5 id="coda_cursor_read_uint8"><code>dst = coda.cursor_read_uint8(cursor)</code></h5>
      <h5 id="coda_cursor_read_int16"><code>dst = coda.cursor_read_int16(cursor)</code></h5>
      <h5 id="coda_cursor_read_uint16"><code>dst = coda.cursor_read_uint16(cursor)</code></h5>
      <h5 id="coda_cursor_read_int32"><code>dst = coda.cursor_read_int32(cursor)</code></h5>
      <h5 id="coda_cursor_read_uint32"><code>dst = coda.cursor_read_uint32(cursor)</code></h5>
      <h5 id="coda_cursor_read_int64"><code>dst = coda.cursor_read_int64(cursor)</code></h5>
      <h5 id="coda_cursor_read_uint64"><code>dst = coda.cursor_read_uint64(cursor)</code></h5>
      <h5 id="coda_cursor_read_float"><code>dst = coda.cursor_read_float(cursor)</code></h5>
      <h5 id="coda_cursor_read_double"><code>dst = coda.cursor_read_double(cursor)</code></h5>
      <h5 id="coda_cursor_read_char"><code>dst = coda.cursor_read_char(cursor)</code></h5>
      <p>Since Python does not have a native char type the character data will be returned as a string of length 1.</p>
      <h5 id="coda_cursor_read_string"><code>dst = coda.cursor_read_string(cursor)</code></h5>
      <h5 id="coda_cursor_read_bits"><code>dst = coda.cursor_read_bits(cursor, bit_offset, bit_length)</code></h5>
      <h5 id="coda_cursor_read_bytes"><code>dst = coda.cursor_read_bytes(cursor, offset, length)</code></h5>
      <h5 id="coda_cursor_read_int8_array"><code>dst = coda.cursor_read_int8_array(cursor)</code></h5>
      <p>No <code>array_ordering</code> parameter is required; CODA will always return the array data in a numpy array object using C array ordering.</p>
      <h5 id="coda_cursor_read_uint8_array"><code>dst = coda.cursor_read_uint8_array(cursor)</code></h5>
      <p>No <code>array_ordering</code> parameter is required; CODA will always return the array data in a numpy array object using C array ordering.</p>
      <h5 id="coda_cursor_read_int16_array"><code>dst = coda.cursor_read_int16_array(cursor)</code></h5>
      <p>No <code>array_ordering</code> parameter is required; CODA will always return the array data in a numpy array object using C array ordering.</p>
      <h5 id="coda_cursor_read_uint16_array"><code>dst = coda.cursor_read_uint16_array(cursor)</code></h5>
      <p>No <code>array_ordering</code> parameter is required; CODA will always return the array data in a numpy array object using C array ordering.</p>
      <h5 id="coda_cursor_read_int32_array"><code>dst = coda.cursor_read_int32_array(cursor)</code></h5>
      <p>No <code>array_ordering</code> parameter is required; CODA will always return the array data in a numpy array object using C array ordering.</p>
      <h5 id="coda_cursor_read_uint32_array"><code>dst = coda.cursor_read_uint32_array(cursor)</code></h5>
      <p>No <code>array_ordering</code> parameter is required; CODA will always return the array data in a numpy array object using C array ordering.</p>
      <h5 id="coda_cursor_read_int64_array"><code>dst = coda.cursor_read_int64_array(cursor)</code></h5>
      <p>No <code>array_ordering</code> parameter is required; CODA will always return the array data in a numpy array object using C array ordering.</p>
      <h5 id="coda_cursor_read_uint64_array"><code>dst = coda.cursor_read_uint64_array(cursor)</code></h5>
      <p>No <code>array_ordering</code> parameter is required; CODA will always return the array data in a numpy array object using C array ordering.</p>
      <h5 id="coda_cursor_read_float_array"><code>dst = coda.cursor_read_float_array(cursor)</code></h5>
      <p>No <code>array_ordering</code> parameter is required; CODA will always return the array data in a numpy array object using C array ordering.</p>
      <h5 id="coda_cursor_read_double_array"><code>dst = coda.cursor_read_double_array(cursor)</code></h5>
      <p>No <code>array_ordering</code> parameter is required; CODA will always return the array data in a numpy array object using C array ordering.</p>
      <h5 id="coda_cursor_read_char_array"><code>dst = coda.cursor_read_char_array(cursor)</code></h5>
      <p>No <code>array_ordering</code> parameter is required; CODA will always return the array data in a numpy array object using C array ordering.</p>
      <p>Since Python does not have a native char type the character array will be returned as an array of signed 8 bit integers.</p>
      <h5 id="coda_cursor_read_int8_partial_array"><code>dst = coda.cursor_read_int8_partial_array(cursor, offset, length)</code></h5>
      <p>CODA will always return the array data in a flat numpy array object using C array ordering.</p>
      <h5 id="coda_cursor_read_uint8_partial_array"><code>dst = coda.cursor_read_uint8_partial_array(cursor, offset, length)</code></h5>
      <p>CODA will always return the array data in a flat numpy array object using C array ordering.</p>
      <h5 id="coda_cursor_read_int16_partial_array"><code>dst = coda.cursor_read_int16_partial_array(cursor, offset, length)</code></h5>
      <p>CODA will always return the array data in a flat numpy array object using C array ordering.</p>
      <h5 id="coda_cursor_read_uint16_partial_array"><code>dst = coda.cursor_read_uint16_partial_array(cursor, offset, length)</code></h5>
      <p>CODA will always return the array data in a flat numpy array object using C array ordering.</p>
      <h5 id="coda_cursor_read_int32_partial_array"><code>dst = coda.cursor_read_int32_partial_array(cursor, offset, length)</code></h5>
      <p>CODA will always return the array data in a flat numpy array object using C array ordering.</p>
      <h5 id="coda_cursor_read_uint32_partial_array"><code>dst = coda.cursor_read_uint32_partial_array(cursor, offset, length)</code></h5>
      <p>CODA will always return the array data in a flat numpy array object using C array ordering.</p>
      <h5 id="coda_cursor_read_int64_partial_array"><code>dst = coda.cursor_read_int64_partial_array(cursor, offset, length)</code></h5>
      <p>CODA will always return the array data in a flat numpy array object using C array ordering.</p>
      <h5 id="coda_cursor_read_uint64_partial_array"><code>dst = coda.cursor_read_uint64_partial_array(cursor, offset, length)</code></h5>
      <p>CODA will always return the array data in a flat numpy array object using C array ordering.</p>
      <h5 id="coda_cursor_read_float_partial_array"><code>dst = coda.cursor_read_float_partial_array(curso, offset, lengthr)</code></h5>
      <p>CODA will always return the array data in a flat numpy array object using C array ordering.</p>
      <h5 id="coda_cursor_read_double_partial_array"><code>dst = coda.cursor_read_double_partial_array(cursor, offset, length)</code></h5>
      <p>CODA will always return the array data in a flat numpy array object using C array ordering.</p>
      <h5 id="coda_cursor_read_char_partial_array"><code>dst = coda.cursor_read_char_partial_array(cursor, offset, length)</code></h5>
      <p>CODA will always return the array data in a flat numpy array object using C array ordering.</p>
      <p>Since Python does not have a native char type the character array will be returned as an array of signed 8 bit integers.</p>
      <h5 id="coda_cursor_read_complex_double_pair"><code>dst = coda.cursor_read_complex_double_pair()</code></h5>
      <h5 id="coda_cursor_read_complex_double_pairs_array"><code>dst = coda.cursor_read_complex_double_pairs_array()</code></h5>
      <p>No <code>array_ordering</code> parameter is required; CODA will always return the array data in a numpy array  object using C array ordering.</p>
      <h5 id="coda_cursor_read_complex_double_split"><code>[dst_re, dst_im] = coda.cursor_read_complex_double_split()</code></h5>
      <h5 id="coda_cursor_read_complex_double_split_array"><code>[dst_re, dst_im] = coda.cursor_read_complex_double_split_array()</code></h5>
      <p>No <code>array_ordering</code> parameter is required; CODA will always return the array data in a numpy array  object using C array ordering.</p>
      <h5 id="coda_expression_get_type_name"><code>stringvalue = coda.expression_get_type_name(expression_type)</code></h5>
      <h5 id="coda_expression_from_string"><code>expr = coda.expression_from_string(exprstring)</code></h5>
      <h5 id="coda_expression_delete"><code>coda.expression_delete(expr)</code></h5>
      <h5 id="coda_expression_get_type"><code>expression_type = coda.expression_get_type(expr)</code></h5>
      <h5 id="coda_expression_is_constant"><code>is_constant = coda.expression_is_constant(expr)</code></h5>
      <h5 id="coda_expression_is_equal"><code>is_equal = coda.expression_is_equal(expr1, expr2)</code></h5>
      <h5 id="coda_expression_eval_bool"><code>boolvalue = coda.expression_eval_bool(expr, cursor=None)</code></h5>
      <h5 id="coda_expression_eval_integer"><code>integervalue = coda.expression_eval_integer(expr, cursor=None)</code></h5>
      <h5 id="coda_expression_eval_float"><code>doublevalue = coda.expression_eval_float(expr, cursor=None)</code></h5>
      <h5 id="coda_expression_eval_string"><code>stringvalue = coda.expression_eval_string(expr, cursor=None)</code></h5>
      <h5 id="coda_expression_eval_node"><code>coda.expression_eval_node(expr, cursor)</code></h5>

      <div class="footer">
        <hr />
        <p>Copyright &copy; 2007-2020 <b>s<span class="soft-red">[</span>&amp;<span class="soft-red">]</span>t</b>, The Netherlands.</p>
      </div>

    </div>

  </body>

</html>
