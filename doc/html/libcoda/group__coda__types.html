<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>CODA Types</title>
<link href="../css/codadoc.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
</head>
<body>
<div class="wide">
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp;
<a class="qindex" href="modules.html">Modules</a> &nbsp;
</center>
<hr>
<!-- Generated by Doxygen 1.10.0 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">CODA Types</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaa4d9bef64d23de166a5e0249504f5afa" id="r_gaa4d9bef64d23de166a5e0249504f5afa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa4d9bef64d23de166a5e0249504f5afa">coda_type_class_enum</a> { <br />
&#160;&#160;<a class="el" href="#ggaa4d9bef64d23de166a5e0249504f5afaae6cd3a620c3acfbfc1bd5e427ac8f7d0">coda_record_class</a>
, <br />
&#160;&#160;<a class="el" href="#ggaa4d9bef64d23de166a5e0249504f5afaa3d28161d8231a5e69ad663cee0502cb3">coda_array_class</a>
, <br />
&#160;&#160;<a class="el" href="#ggaa4d9bef64d23de166a5e0249504f5afaa7b0a5823955f5cd50c723fde30432a5b">coda_integer_class</a>
, <br />
&#160;&#160;<a class="el" href="#ggaa4d9bef64d23de166a5e0249504f5afaab6206bdb3d35dde97b3713bf811a79ec">coda_real_class</a>
, <br />
&#160;&#160;<a class="el" href="#ggaa4d9bef64d23de166a5e0249504f5afaa11d9a0b0ca20c41c9b6ebd492ffd3e0a">coda_text_class</a>
, <br />
&#160;&#160;<a class="el" href="#ggaa4d9bef64d23de166a5e0249504f5afaa70337e3bf4f60b59f028b2b33f62f708">coda_raw_class</a>
, <br />
&#160;&#160;<a class="el" href="#ggaa4d9bef64d23de166a5e0249504f5afaa5d605b83d52f350f6525d9ee8576f34f">coda_special_class</a>
<br />
 }</td></tr>
<tr class="separator:gaa4d9bef64d23de166a5e0249504f5afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0124a9650f42b5f4eb2eb21535539eb" id="r_gab0124a9650f42b5f4eb2eb21535539eb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab0124a9650f42b5f4eb2eb21535539eb">coda_special_type_enum</a> { <br />
&#160;&#160;<a class="el" href="#ggab0124a9650f42b5f4eb2eb21535539ebae9150e17f22a06e36de3dc1037047d00">coda_special_no_data</a>
, <br />
&#160;&#160;<a class="el" href="#ggab0124a9650f42b5f4eb2eb21535539ebaab170e500c7fb9748fb5de6de1475437">coda_special_vsf_integer</a>
, <br />
&#160;&#160;<a class="el" href="#ggab0124a9650f42b5f4eb2eb21535539ebabd6083accbf471d6e0c621353cd62d16">coda_special_time</a>
, <br />
&#160;&#160;<a class="el" href="#ggab0124a9650f42b5f4eb2eb21535539eba7298ffbdd7d5618689d4183c3e3de865">coda_special_complex</a>
<br />
 }</td></tr>
<tr class="separator:gab0124a9650f42b5f4eb2eb21535539eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29df10be1deb83bcf6ec8ea6064cfe46" id="r_ga29df10be1deb83bcf6ec8ea6064cfe46"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga29df10be1deb83bcf6ec8ea6064cfe46">coda_native_type_enum</a> { <br />
&#160;&#160;<a class="el" href="#gga29df10be1deb83bcf6ec8ea6064cfe46a7844219b3368ea30745c55cefdf239d6">coda_native_type_not_available</a> = -1
, <br />
&#160;&#160;<a class="el" href="#gga29df10be1deb83bcf6ec8ea6064cfe46ad3cf43d4413d405a1817f524895a85b5">coda_native_type_int8</a>
, <br />
&#160;&#160;<a class="el" href="#gga29df10be1deb83bcf6ec8ea6064cfe46a5e9fc5a4d77a50e0b630192c5aa62823">coda_native_type_uint8</a>
, <br />
&#160;&#160;<a class="el" href="#gga29df10be1deb83bcf6ec8ea6064cfe46a1c36204049df28689e6825ddde05dbad">coda_native_type_int16</a>
, <br />
&#160;&#160;<a class="el" href="#gga29df10be1deb83bcf6ec8ea6064cfe46aad92bc7e294efedea16e8a8f7976c1fb">coda_native_type_uint16</a>
, <br />
&#160;&#160;<a class="el" href="#gga29df10be1deb83bcf6ec8ea6064cfe46ad032bb3e98707ae1b6833f9ed962e854">coda_native_type_int32</a>
, <br />
&#160;&#160;<a class="el" href="#gga29df10be1deb83bcf6ec8ea6064cfe46ab1ac10dcda6045a3ee68d07d2326900a">coda_native_type_uint32</a>
, <br />
&#160;&#160;<a class="el" href="#gga29df10be1deb83bcf6ec8ea6064cfe46accc5b0ede556ff574063a41cd460cf3a">coda_native_type_int64</a>
, <br />
&#160;&#160;<a class="el" href="#gga29df10be1deb83bcf6ec8ea6064cfe46a9ca08851ec40145bc9460a560a2fe4cd">coda_native_type_uint64</a>
, <br />
&#160;&#160;<a class="el" href="#gga29df10be1deb83bcf6ec8ea6064cfe46a76554948d11fb6ccb19cc92cb4edd9c8">coda_native_type_float</a>
, <br />
&#160;&#160;<a class="el" href="#gga29df10be1deb83bcf6ec8ea6064cfe46abfb0ef3b4696c83d742bbe44f9c6ec48">coda_native_type_double</a>
, <br />
&#160;&#160;<a class="el" href="#gga29df10be1deb83bcf6ec8ea6064cfe46a4e3453a635fc351bc560916d2053b1df">coda_native_type_char</a>
, <br />
&#160;&#160;<a class="el" href="#gga29df10be1deb83bcf6ec8ea6064cfe46ac1b9f0752a9ed4d5c07e77cc7292dba8">coda_native_type_string</a>
, <br />
&#160;&#160;<a class="el" href="#gga29df10be1deb83bcf6ec8ea6064cfe46a22f9a7f98b86d624663b93c68efc6227">coda_native_type_bytes</a>
<br />
 }</td></tr>
<tr class="separator:ga29df10be1deb83bcf6ec8ea6064cfe46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga425a037707b53156011570572cc66455" id="r_ga425a037707b53156011570572cc66455"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga425a037707b53156011570572cc66455">coda_type_get_format_name</a> (coda_format format)</td></tr>
<tr class="separator:ga425a037707b53156011570572cc66455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42d70cf6794fad361a9c010ddff7194c" id="r_ga42d70cf6794fad361a9c010ddff7194c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga42d70cf6794fad361a9c010ddff7194c">coda_type_get_class_name</a> (coda_type_class type_class)</td></tr>
<tr class="separator:ga42d70cf6794fad361a9c010ddff7194c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dff55e12a0535bfde803fb68fb68a2e" id="r_ga7dff55e12a0535bfde803fb68fb68a2e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7dff55e12a0535bfde803fb68fb68a2e">coda_type_get_native_type_name</a> (coda_native_type native_type)</td></tr>
<tr class="separator:ga7dff55e12a0535bfde803fb68fb68a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9530373dbbdb5def369f247c9f773178" id="r_ga9530373dbbdb5def369f247c9f773178"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9530373dbbdb5def369f247c9f773178">coda_type_get_special_type_name</a> (coda_special_type special_type)</td></tr>
<tr class="separator:ga9530373dbbdb5def369f247c9f773178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga682a957fd2ba53edbab6219394cbf7d3" id="r_ga682a957fd2ba53edbab6219394cbf7d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga682a957fd2ba53edbab6219394cbf7d3">coda_type_has_attributes</a> (const coda_type *type, int *has_attributes)</td></tr>
<tr class="separator:ga682a957fd2ba53edbab6219394cbf7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd578623f4a02d0132abe2ff81bab1bd" id="r_gadd578623f4a02d0132abe2ff81bab1bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadd578623f4a02d0132abe2ff81bab1bd">coda_type_get_format</a> (const coda_type *type, coda_format *format)</td></tr>
<tr class="separator:gadd578623f4a02d0132abe2ff81bab1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b352b8859784c0d8a542dedbea13b66" id="r_ga6b352b8859784c0d8a542dedbea13b66"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6b352b8859784c0d8a542dedbea13b66">coda_type_get_class</a> (const coda_type *type, coda_type_class *type_class)</td></tr>
<tr class="separator:ga6b352b8859784c0d8a542dedbea13b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae851e4b1832b37f4fe8f25e4a7485ebe" id="r_gae851e4b1832b37f4fe8f25e4a7485ebe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae851e4b1832b37f4fe8f25e4a7485ebe">coda_type_get_read_type</a> (const coda_type *type, coda_native_type *read_type)</td></tr>
<tr class="separator:gae851e4b1832b37f4fe8f25e4a7485ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20e53281d64b697447f0dfc4411fdce8" id="r_ga20e53281d64b697447f0dfc4411fdce8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga20e53281d64b697447f0dfc4411fdce8">coda_type_get_string_length</a> (const coda_type *type, long *length)</td></tr>
<tr class="separator:ga20e53281d64b697447f0dfc4411fdce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31628bda5c001db1aa34d9adf590b734" id="r_ga31628bda5c001db1aa34d9adf590b734"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga31628bda5c001db1aa34d9adf590b734">coda_type_get_bit_size</a> (const coda_type *type, int64_t *bit_size)</td></tr>
<tr class="separator:ga31628bda5c001db1aa34d9adf590b734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac7335f81e32f69ac6d207d02a822091" id="r_gaac7335f81e32f69ac6d207d02a822091"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaac7335f81e32f69ac6d207d02a822091">coda_type_get_name</a> (const coda_type *type, const char **name)</td></tr>
<tr class="separator:gaac7335f81e32f69ac6d207d02a822091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5920cdb82425c7a4554e3293edbca12" id="r_gaf5920cdb82425c7a4554e3293edbca12"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf5920cdb82425c7a4554e3293edbca12">coda_type_get_description</a> (const coda_type *type, const char **description)</td></tr>
<tr class="separator:gaf5920cdb82425c7a4554e3293edbca12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc3e3c3c022db1100473a76d407e83c2" id="r_gacc3e3c3c022db1100473a76d407e83c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacc3e3c3c022db1100473a76d407e83c2">coda_type_get_unit</a> (const coda_type *type, const char **unit)</td></tr>
<tr class="separator:gacc3e3c3c022db1100473a76d407e83c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0b43d87786bce79d957df5b9a02d7b5" id="r_gac0b43d87786bce79d957df5b9a02d7b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac0b43d87786bce79d957df5b9a02d7b5">coda_type_get_fixed_value</a> (const coda_type *type, const char **fixed_value, long *length)</td></tr>
<tr class="separator:gac0b43d87786bce79d957df5b9a02d7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10d2b4f9c483cc50f645f36246738e47" id="r_ga10d2b4f9c483cc50f645f36246738e47"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga10d2b4f9c483cc50f645f36246738e47">coda_type_get_attributes</a> (const coda_type *type, coda_type **attributes)</td></tr>
<tr class="separator:ga10d2b4f9c483cc50f645f36246738e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbb031cb93c024b82f5a465c6da5e969" id="r_gafbb031cb93c024b82f5a465c6da5e969"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafbb031cb93c024b82f5a465c6da5e969">coda_type_get_num_record_fields</a> (const coda_type *type, long *num_fields)</td></tr>
<tr class="separator:gafbb031cb93c024b82f5a465c6da5e969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d09c82ae9fe49493b627303cbd30a1e" id="r_ga9d09c82ae9fe49493b627303cbd30a1e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9d09c82ae9fe49493b627303cbd30a1e">coda_type_get_record_field_index_from_name</a> (const coda_type *type, const char *name, long *index)</td></tr>
<tr class="separator:ga9d09c82ae9fe49493b627303cbd30a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9c0f013b6188abab7eee08ad8533f48" id="r_gad9c0f013b6188abab7eee08ad8533f48"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad9c0f013b6188abab7eee08ad8533f48">coda_type_get_record_field_index_from_real_name</a> (const coda_type *type, const char *real_name, long *index)</td></tr>
<tr class="separator:gad9c0f013b6188abab7eee08ad8533f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d857c5b8a203b23e40e6be4f0e651c0" id="r_ga9d857c5b8a203b23e40e6be4f0e651c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9d857c5b8a203b23e40e6be4f0e651c0">coda_type_get_record_field_type</a> (const coda_type *type, long index, coda_type **field_type)</td></tr>
<tr class="separator:ga9d857c5b8a203b23e40e6be4f0e651c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac00e6ae545d1f81ca19d15e8be2027a9" id="r_gac00e6ae545d1f81ca19d15e8be2027a9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac00e6ae545d1f81ca19d15e8be2027a9">coda_type_get_record_field_name</a> (const coda_type *type, long index, const char **name)</td></tr>
<tr class="separator:gac00e6ae545d1f81ca19d15e8be2027a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga075a805485da07db1480a38b988175ec" id="r_ga075a805485da07db1480a38b988175ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga075a805485da07db1480a38b988175ec">coda_type_get_record_field_real_name</a> (const coda_type *type, long index, const char **real_name)</td></tr>
<tr class="separator:ga075a805485da07db1480a38b988175ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69a9241c8968e8f176a66d96bc4761ad" id="r_ga69a9241c8968e8f176a66d96bc4761ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga69a9241c8968e8f176a66d96bc4761ad">coda_type_get_record_field_hidden_status</a> (const coda_type *type, long index, int *hidden)</td></tr>
<tr class="separator:ga69a9241c8968e8f176a66d96bc4761ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f6b27b66e48f2c1482f825102a24eca" id="r_ga7f6b27b66e48f2c1482f825102a24eca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7f6b27b66e48f2c1482f825102a24eca">coda_type_get_record_field_available_status</a> (const coda_type *type, long index, int *available)</td></tr>
<tr class="separator:ga7f6b27b66e48f2c1482f825102a24eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d6624197f226411f0b063ab3eb554b2" id="r_ga6d6624197f226411f0b063ab3eb554b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6d6624197f226411f0b063ab3eb554b2">coda_type_get_record_union_status</a> (const coda_type *type, int *is_union)</td></tr>
<tr class="separator:ga6d6624197f226411f0b063ab3eb554b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84eefee396791a10bfebec6d0414a8a3" id="r_ga84eefee396791a10bfebec6d0414a8a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga84eefee396791a10bfebec6d0414a8a3">coda_type_get_array_num_dims</a> (const coda_type *type, int *num_dims)</td></tr>
<tr class="separator:ga84eefee396791a10bfebec6d0414a8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6fdd1c5b5ec9a774c909352708fbc97" id="r_gad6fdd1c5b5ec9a774c909352708fbc97"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad6fdd1c5b5ec9a774c909352708fbc97">coda_type_get_array_dim</a> (const coda_type *type, int *num_dims, long dim[])</td></tr>
<tr class="separator:gad6fdd1c5b5ec9a774c909352708fbc97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga182b144b563586f8cb2aecfad8bac873" id="r_ga182b144b563586f8cb2aecfad8bac873"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga182b144b563586f8cb2aecfad8bac873">coda_type_get_array_base_type</a> (const coda_type *type, coda_type **base_type)</td></tr>
<tr class="separator:ga182b144b563586f8cb2aecfad8bac873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1fb786cae51605b82ed6f93bd69172e" id="r_gad1fb786cae51605b82ed6f93bd69172e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad1fb786cae51605b82ed6f93bd69172e">coda_type_get_special_type</a> (const coda_type *type, coda_special_type *special_type)</td></tr>
<tr class="separator:gad1fb786cae51605b82ed6f93bd69172e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga693a083ef0514742a4eedcc432a1dd6b" id="r_ga693a083ef0514742a4eedcc432a1dd6b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga693a083ef0514742a4eedcc432a1dd6b">coda_type_get_special_base_type</a> (const coda_type *type, coda_type **base_type)</td></tr>
<tr class="separator:ga693a083ef0514742a4eedcc432a1dd6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Each data element or group of data elements (such as an array or record) in a product file has a unique description, in CODA. This description is independent of the file format of the product (e.g. ascii, binary, XML, netCDF, etc.) Each of those descriptions is referred to as a CODA type (which is of type coda_type). For self describing formats such as netCDF, HDF4, and HDF5 files the type definition is taken from the products themselves. For other formats, such as ascii and binary products the type definition is fixed and is provided by .codadef files. For some file formats CODA can use a predefined format stored in a .codadef file to further restricit the format of a self describing file. For XML files, for instance, CODA will treat all 'leaf elements' as ascii text if no definition for the product is available in a .codadef. However, with a definition, CODA will know how to interpret the 'leaf elements' (i.e. whether the content of an XML element should be a string, an integer, a time value, etc.).</p>
<p>As an example, there is a type that describes the MPH of an ENVISAT product (which is a record). This record contains a name, a textual description, the number of fields, and for each of the fields the field name and (again) a CODA type describing that field.</p>
<p>CODA types are grouped into several classes (coda_type_class). The available classes are:</p><ul>
<li>record (<a class="el" href="#ggaa4d9bef64d23de166a5e0249504f5afaae6cd3a620c3acfbfc1bd5e427ac8f7d0">coda_record_class</a>)</li>
<li>array (<a class="el" href="#ggaa4d9bef64d23de166a5e0249504f5afaa3d28161d8231a5e69ad663cee0502cb3">coda_array_class</a>)</li>
<li>integer (<a class="el" href="#ggaa4d9bef64d23de166a5e0249504f5afaa7b0a5823955f5cd50c723fde30432a5b">coda_integer_class</a>)</li>
<li>real (<a class="el" href="#ggaa4d9bef64d23de166a5e0249504f5afaab6206bdb3d35dde97b3713bf811a79ec">coda_real_class</a>)</li>
<li>text (<a class="el" href="#ggaa4d9bef64d23de166a5e0249504f5afaa11d9a0b0ca20c41c9b6ebd492ffd3e0a">coda_text_class</a>)</li>
<li>raw (<a class="el" href="#ggaa4d9bef64d23de166a5e0249504f5afaa70337e3bf4f60b59f028b2b33f62f708">coda_raw_class</a>)</li>
<li>special (<a class="el" href="#ggaa4d9bef64d23de166a5e0249504f5afaa5d605b83d52f350f6525d9ee8576f34f">coda_special_class</a>)</li>
</ul>
<p>The record and array types are the compound types that structurally define the product. It is possible to have records which fields are again records or arrays and arrays may have again arrays or records as elements. At the deepest level of a product tree (i.e. the 'leaf elements') you will allways find a basic type. These basic types are represented by the classes integer, real, text, and raw for respectively integer numbers, floating point numbers, text strings, and series of uninterpreted bytes.</p>
<p>For each of the basic type classes you can use the <a class="el" href="#gae851e4b1832b37f4fe8f25e4a7485ebe">coda_type_get_read_type()</a> function to determine the best native type (coda_native_type) in which to store the data as it is read from file into memory. The native types contain signed and unsigned integers ranging from 8 to 64 bits, the float and double types, char and string for textual information, and a special bytes type for raw data.</p>
<p>Finally, CODA also supports several special data types (<a class="el" href="#ggaa4d9bef64d23de166a5e0249504f5afaa5d605b83d52f350f6525d9ee8576f34f">coda_special_class</a>, coda_special_type). These are types that provide a mapping from the data in a product to a more convenient type for you as user. For example, there is a special time type that converts the many time formats that are used in products to a double value representing the amount of seconds since 2000-01-01T00:00:00.000000, which is the default time format in CODA. When you encounter a special type you can always use the <a class="el" href="#ga693a083ef0514742a4eedcc432a1dd6b">coda_type_get_special_base_type()</a> function to bypass the special interpretation of the data and look at the data in its actual form (e.g. for an ASCII time string you will get a <a class="el" href="#ggaa4d9bef64d23de166a5e0249504f5afaa11d9a0b0ca20c41c9b6ebd492ffd3e0a">coda_text_class</a> type).</p>
<p>CODA is able to deal with many dynamic properties that can be encountered in product files. Some of these dynamic properties are: the size of arrays, the availabillity of optional record fields, the bit/byte offset of record fields, and the size of string data or raw data. For data types where these properties are dynamic, you will only be able to retrieve the actual size/availabillity/etc. by moving a cursor to the data element and use the CODA Cursor functions to retrieve the requested property (e.g. if the size of an array is not fixed, <a class="el" href="#gad6fdd1c5b5ec9a774c909352708fbc97">coda_type_get_array_dim()</a> will return a dimension value of -1 and <a class="el" href="group__coda__cursor.html#gac383bb48a0aef63af6c128e8af96238a">coda_cursor_get_array_dim()</a> will return the real dimension value).</p>
<p>More information about the CODA types and descriptions of the mappings of self describing formats to CODA types can be found in other parts of the CODA documentation that is included with the CODA package.</p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga29df10be1deb83bcf6ec8ea6064cfe46" name="ga29df10be1deb83bcf6ec8ea6064cfe46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29df10be1deb83bcf6ec8ea6064cfe46">&#9670;&#160;</a></span>coda_native_type_enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ga29df10be1deb83bcf6ec8ea6064cfe46">coda_native_type_enum</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga29df10be1deb83bcf6ec8ea6064cfe46a7844219b3368ea30745c55cefdf239d6" name="gga29df10be1deb83bcf6ec8ea6064cfe46a7844219b3368ea30745c55cefdf239d6"></a>coda_native_type_not_available&#160;</td><td class="fielddoc"><p>native type value for compound entities that can not be read directly </p>
</td></tr>
<tr><td class="fieldname"><a id="gga29df10be1deb83bcf6ec8ea6064cfe46ad3cf43d4413d405a1817f524895a85b5" name="gga29df10be1deb83bcf6ec8ea6064cfe46ad3cf43d4413d405a1817f524895a85b5"></a>coda_native_type_int8&#160;</td><td class="fielddoc"><p>8 bit signed integer (<a class="el" href="#ggaa4d9bef64d23de166a5e0249504f5afaa7b0a5823955f5cd50c723fde30432a5b">coda_integer_class</a>) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga29df10be1deb83bcf6ec8ea6064cfe46a5e9fc5a4d77a50e0b630192c5aa62823" name="gga29df10be1deb83bcf6ec8ea6064cfe46a5e9fc5a4d77a50e0b630192c5aa62823"></a>coda_native_type_uint8&#160;</td><td class="fielddoc"><p>8 bit unsigned integer (<a class="el" href="#ggaa4d9bef64d23de166a5e0249504f5afaa7b0a5823955f5cd50c723fde30432a5b">coda_integer_class</a>) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga29df10be1deb83bcf6ec8ea6064cfe46a1c36204049df28689e6825ddde05dbad" name="gga29df10be1deb83bcf6ec8ea6064cfe46a1c36204049df28689e6825ddde05dbad"></a>coda_native_type_int16&#160;</td><td class="fielddoc"><p>16 bit signed integer (<a class="el" href="#ggaa4d9bef64d23de166a5e0249504f5afaa7b0a5823955f5cd50c723fde30432a5b">coda_integer_class</a>) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga29df10be1deb83bcf6ec8ea6064cfe46aad92bc7e294efedea16e8a8f7976c1fb" name="gga29df10be1deb83bcf6ec8ea6064cfe46aad92bc7e294efedea16e8a8f7976c1fb"></a>coda_native_type_uint16&#160;</td><td class="fielddoc"><p>16 bit unsigned integer (<a class="el" href="#ggaa4d9bef64d23de166a5e0249504f5afaa7b0a5823955f5cd50c723fde30432a5b">coda_integer_class</a>) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga29df10be1deb83bcf6ec8ea6064cfe46ad032bb3e98707ae1b6833f9ed962e854" name="gga29df10be1deb83bcf6ec8ea6064cfe46ad032bb3e98707ae1b6833f9ed962e854"></a>coda_native_type_int32&#160;</td><td class="fielddoc"><p>32 bit signed integer (<a class="el" href="#ggaa4d9bef64d23de166a5e0249504f5afaa7b0a5823955f5cd50c723fde30432a5b">coda_integer_class</a>) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga29df10be1deb83bcf6ec8ea6064cfe46ab1ac10dcda6045a3ee68d07d2326900a" name="gga29df10be1deb83bcf6ec8ea6064cfe46ab1ac10dcda6045a3ee68d07d2326900a"></a>coda_native_type_uint32&#160;</td><td class="fielddoc"><p>32 bit unsigned integer (<a class="el" href="#ggaa4d9bef64d23de166a5e0249504f5afaa7b0a5823955f5cd50c723fde30432a5b">coda_integer_class</a>) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga29df10be1deb83bcf6ec8ea6064cfe46accc5b0ede556ff574063a41cd460cf3a" name="gga29df10be1deb83bcf6ec8ea6064cfe46accc5b0ede556ff574063a41cd460cf3a"></a>coda_native_type_int64&#160;</td><td class="fielddoc"><p>64 bit signed integer (<a class="el" href="#ggaa4d9bef64d23de166a5e0249504f5afaa7b0a5823955f5cd50c723fde30432a5b">coda_integer_class</a>) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga29df10be1deb83bcf6ec8ea6064cfe46a9ca08851ec40145bc9460a560a2fe4cd" name="gga29df10be1deb83bcf6ec8ea6064cfe46a9ca08851ec40145bc9460a560a2fe4cd"></a>coda_native_type_uint64&#160;</td><td class="fielddoc"><p>64 bit unsigned integer (<a class="el" href="#ggaa4d9bef64d23de166a5e0249504f5afaa7b0a5823955f5cd50c723fde30432a5b">coda_integer_class</a>) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga29df10be1deb83bcf6ec8ea6064cfe46a76554948d11fb6ccb19cc92cb4edd9c8" name="gga29df10be1deb83bcf6ec8ea6064cfe46a76554948d11fb6ccb19cc92cb4edd9c8"></a>coda_native_type_float&#160;</td><td class="fielddoc"><p>32 bit IEEE floating point type (<a class="el" href="#ggaa4d9bef64d23de166a5e0249504f5afaab6206bdb3d35dde97b3713bf811a79ec">coda_real_class</a>) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga29df10be1deb83bcf6ec8ea6064cfe46abfb0ef3b4696c83d742bbe44f9c6ec48" name="gga29df10be1deb83bcf6ec8ea6064cfe46abfb0ef3b4696c83d742bbe44f9c6ec48"></a>coda_native_type_double&#160;</td><td class="fielddoc"><p>64 bit IEEE floating point type (<a class="el" href="#ggaa4d9bef64d23de166a5e0249504f5afaab6206bdb3d35dde97b3713bf811a79ec">coda_real_class</a>) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga29df10be1deb83bcf6ec8ea6064cfe46a4e3453a635fc351bc560916d2053b1df" name="gga29df10be1deb83bcf6ec8ea6064cfe46a4e3453a635fc351bc560916d2053b1df"></a>coda_native_type_char&#160;</td><td class="fielddoc"><p>single character (<a class="el" href="#ggaa4d9bef64d23de166a5e0249504f5afaa11d9a0b0ca20c41c9b6ebd492ffd3e0a">coda_text_class</a>) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga29df10be1deb83bcf6ec8ea6064cfe46ac1b9f0752a9ed4d5c07e77cc7292dba8" name="gga29df10be1deb83bcf6ec8ea6064cfe46ac1b9f0752a9ed4d5c07e77cc7292dba8"></a>coda_native_type_string&#160;</td><td class="fielddoc"><p>string (<a class="el" href="#ggaa4d9bef64d23de166a5e0249504f5afaa11d9a0b0ca20c41c9b6ebd492ffd3e0a">coda_text_class</a>) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga29df10be1deb83bcf6ec8ea6064cfe46a22f9a7f98b86d624663b93c68efc6227" name="gga29df10be1deb83bcf6ec8ea6064cfe46a22f9a7f98b86d624663b93c68efc6227"></a>coda_native_type_bytes&#160;</td><td class="fielddoc"><p>series of uninterpreted bytes (<a class="el" href="#ggaa4d9bef64d23de166a5e0249504f5afaa70337e3bf4f60b59f028b2b33f62f708">coda_raw_class</a>) </p>
</td></tr>
</table>

</div>
</div>
<a id="gab0124a9650f42b5f4eb2eb21535539eb" name="gab0124a9650f42b5f4eb2eb21535539eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0124a9650f42b5f4eb2eb21535539eb">&#9670;&#160;</a></span>coda_special_type_enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#gab0124a9650f42b5f4eb2eb21535539eb">coda_special_type_enum</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab0124a9650f42b5f4eb2eb21535539ebae9150e17f22a06e36de3dc1037047d00" name="ggab0124a9650f42b5f4eb2eb21535539ebae9150e17f22a06e36de3dc1037047d00"></a>coda_special_no_data&#160;</td><td class="fielddoc"><p>No data (data object is not available) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab0124a9650f42b5f4eb2eb21535539ebaab170e500c7fb9748fb5de6de1475437" name="ggab0124a9650f42b5f4eb2eb21535539ebaab170e500c7fb9748fb5de6de1475437"></a>coda_special_vsf_integer&#160;</td><td class="fielddoc"><p>A compound containing a variable scale factor and an integer. The returned double value equals: integer_value x 10^(-scale_factor) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab0124a9650f42b5f4eb2eb21535539ebabd6083accbf471d6e0c621353cd62d16" name="ggab0124a9650f42b5f4eb2eb21535539ebabd6083accbf471d6e0c621353cd62d16"></a>coda_special_time&#160;</td><td class="fielddoc"><p>Data specifying a date/time value </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab0124a9650f42b5f4eb2eb21535539eba7298ffbdd7d5618689d4183c3e3de865" name="ggab0124a9650f42b5f4eb2eb21535539eba7298ffbdd7d5618689d4183c3e3de865"></a>coda_special_complex&#160;</td><td class="fielddoc"><p>Data consisting of a real and imaginary value </p>
</td></tr>
</table>

</div>
</div>
<a id="gaa4d9bef64d23de166a5e0249504f5afa" name="gaa4d9bef64d23de166a5e0249504f5afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4d9bef64d23de166a5e0249504f5afa">&#9670;&#160;</a></span>coda_type_class_enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#gaa4d9bef64d23de166a5e0249504f5afa">coda_type_class_enum</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa4d9bef64d23de166a5e0249504f5afaae6cd3a620c3acfbfc1bd5e427ac8f7d0" name="ggaa4d9bef64d23de166a5e0249504f5afaae6cd3a620c3acfbfc1bd5e427ac8f7d0"></a>coda_record_class&#160;</td><td class="fielddoc"><p>Class of all record types </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa4d9bef64d23de166a5e0249504f5afaa3d28161d8231a5e69ad663cee0502cb3" name="ggaa4d9bef64d23de166a5e0249504f5afaa3d28161d8231a5e69ad663cee0502cb3"></a>coda_array_class&#160;</td><td class="fielddoc"><p>Class of all array types </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa4d9bef64d23de166a5e0249504f5afaa7b0a5823955f5cd50c723fde30432a5b" name="ggaa4d9bef64d23de166a5e0249504f5afaa7b0a5823955f5cd50c723fde30432a5b"></a>coda_integer_class&#160;</td><td class="fielddoc"><p>Class of all integer types </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa4d9bef64d23de166a5e0249504f5afaab6206bdb3d35dde97b3713bf811a79ec" name="ggaa4d9bef64d23de166a5e0249504f5afaab6206bdb3d35dde97b3713bf811a79ec"></a>coda_real_class&#160;</td><td class="fielddoc"><p>Class of all real (floating point) types </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa4d9bef64d23de166a5e0249504f5afaa11d9a0b0ca20c41c9b6ebd492ffd3e0a" name="ggaa4d9bef64d23de166a5e0249504f5afaa11d9a0b0ca20c41c9b6ebd492ffd3e0a"></a>coda_text_class&#160;</td><td class="fielddoc"><p>Class of all text types </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa4d9bef64d23de166a5e0249504f5afaa70337e3bf4f60b59f028b2b33f62f708" name="ggaa4d9bef64d23de166a5e0249504f5afaa70337e3bf4f60b59f028b2b33f62f708"></a>coda_raw_class&#160;</td><td class="fielddoc"><p>Class of all unformatted types (data that is not interpreted) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa4d9bef64d23de166a5e0249504f5afaa5d605b83d52f350f6525d9ee8576f34f" name="ggaa4d9bef64d23de166a5e0249504f5afaa5d605b83d52f350f6525d9ee8576f34f"></a>coda_special_class&#160;</td><td class="fielddoc"><p>Class of all special data types (such as time and complex) </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga182b144b563586f8cb2aecfad8bac873" name="ga182b144b563586f8cb2aecfad8bac873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga182b144b563586f8cb2aecfad8bac873">&#9670;&#160;</a></span>coda_type_get_array_base_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_type_get_array_base_type </td>
          <td>(</td>
          <td class="paramtype">const coda_type *</td>          <td class="paramname"><span class="paramname"><em>type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">coda_type **</td>          <td class="paramname"><span class="paramname"><em>base_type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the CODA type for the elements of an array. If the type is not an array class the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>CODA type. </td></tr>
    <tr><td class="paramname">base_type</td><td>Pointer to the variable where the base type will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check coda_errno). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gad6fdd1c5b5ec9a774c909352708fbc97" name="gad6fdd1c5b5ec9a774c909352708fbc97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6fdd1c5b5ec9a774c909352708fbc97">&#9670;&#160;</a></span>coda_type_get_array_dim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_type_get_array_dim </td>
          <td>(</td>
          <td class="paramtype">const coda_type *</td>          <td class="paramname"><span class="paramname"><em>type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>num_dims</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em>[]</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the dimensions with a constant value for an array. The function returns both the number of dimensions <em>num_dims</em> and the size for each of the dimensions <em>dim</em> that have a constant/fixed size. </p><dl class="section note"><dt>Note</dt><dd>If the size of a dimension is variable (it differs per product or differs per occurrence inside one product) then this function will set the value for that dimension to <code>-1</code>. Otherwise it will set the dimension entry in <em>dim</em> to the constant value for that dimension as defined by the CODA product format definition. Variable dimension sizes can only occur when a CODA product format definition is used. If the type is not an array class the function will return an error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>CODA type. </td></tr>
    <tr><td class="paramname">num_dims</td><td>Pointer to the variable where the number of dimensions will be stored. </td></tr>
    <tr><td class="paramname">dim</td><td>Pointer to the variable where the dimensions will be stored. Dimensions that will vary per product or within a product will have value <code>-1</code>. The caller needs to make sure that the variable has enough room to store the dimensions array. It is guaranteed that the number of dimensions will never exceed <a class="el" href="group__coda__general.html#ga23cf6b5f0dccbf849cf656acd3f5b211">CODA_MAX_NUM_DIMS</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check coda_errno). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga84eefee396791a10bfebec6d0414a8a3" name="ga84eefee396791a10bfebec6d0414a8a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84eefee396791a10bfebec6d0414a8a3">&#9670;&#160;</a></span>coda_type_get_array_num_dims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_type_get_array_num_dims </td>
          <td>(</td>
          <td class="paramtype">const coda_type *</td>          <td class="paramname"><span class="paramname"><em>type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>num_dims</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of dimensions for an array. If the type is not an array class the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>CODA type. </td></tr>
    <tr><td class="paramname">num_dims</td><td>Pointer to the variable where the number of dimensions will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check coda_errno). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga10d2b4f9c483cc50f645f36246738e47" name="ga10d2b4f9c483cc50f645f36246738e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10d2b4f9c483cc50f645f36246738e47">&#9670;&#160;</a></span>coda_type_get_attributes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_type_get_attributes </td>
          <td>(</td>
          <td class="paramtype">const coda_type *</td>          <td class="paramname"><span class="paramname"><em>type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">coda_type **</td>          <td class="paramname"><span class="paramname"><em>attributes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the type for the associated attribute record. Note that this record may not have any fields if there are no attributes for this type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>CODA type. </td></tr>
    <tr><td class="paramname">attributes</td><td>Pointer to the variable where the pointer to the type defining the attribute record will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check coda_errno). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga31628bda5c001db1aa34d9adf590b734" name="ga31628bda5c001db1aa34d9adf590b734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31628bda5c001db1aa34d9adf590b734">&#9670;&#160;</a></span>coda_type_get_bit_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_type_get_bit_size </td>
          <td>(</td>
          <td class="paramtype">const coda_type *</td>          <td class="paramname"><span class="paramname"><em>type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *</td>          <td class="paramname"><span class="paramname"><em>bit_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the bit size for the data type. Depending on the type of data and its format this function will return the following: For data in ascii or binary format all data types will return the amount of bits the data occupies in the product file. This means that e.g. ascii floats and ascii integers will return 8 times the byte size of the ascii representation, records and arrays return the sum of the bit sizes of their fields/array-elements. For XML data you will be able to retrieve bit sizes for all data except arrays and attribute records. You will not be able to retrieve bit/byte sizes for data in netCDF, HDF4, or HDF5 format. If the size is not fixed and can only be determined from information inside a product then <em>bit_size</em> will be set to -1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>CODA type. </td></tr>
    <tr><td class="paramname">bit_size</td><td>Pointer to a variable where the bit size will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check coda_errno). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga6b352b8859784c0d8a542dedbea13b66" name="ga6b352b8859784c0d8a542dedbea13b66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b352b8859784c0d8a542dedbea13b66">&#9670;&#160;</a></span>coda_type_get_class()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_type_get_class </td>
          <td>(</td>
          <td class="paramtype">const coda_type *</td>          <td class="paramname"><span class="paramname"><em>type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">coda_type_class *</td>          <td class="paramname"><span class="paramname"><em>type_class</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the class of a type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>CODA type. </td></tr>
    <tr><td class="paramname">type_class</td><td>Pointer to a variable where the type class will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check coda_errno). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga42d70cf6794fad361a9c010ddff7194c" name="ga42d70cf6794fad361a9c010ddff7194c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42d70cf6794fad361a9c010ddff7194c">&#9670;&#160;</a></span>coda_type_get_class_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * coda_type_get_class_name </td>
          <td>(</td>
          <td class="paramtype">coda_type_class</td>          <td class="paramname"><span class="paramname"><em>type_class</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the name of a type class. In case the type class is not recognised the string "unknown" is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_class</td><td>CODA type class </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the type class is known a string containing the name of the class, otherwise the string "unknown". </dd></dl>

</div>
</div>
<a id="gaf5920cdb82425c7a4554e3293edbca12" name="gaf5920cdb82425c7a4554e3293edbca12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5920cdb82425c7a4554e3293edbca12">&#9670;&#160;</a></span>coda_type_get_description()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_type_get_description </td>
          <td>(</td>
          <td class="paramtype">const coda_type *</td>          <td class="paramname"><span class="paramname"><em>type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>description</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the description of a type. If the type does not have a description a NULL pointer will be returned. The <em>description</em> parameter will either be a NULL pointer or a 0 terminated string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>CODA type. </td></tr>
    <tr><td class="paramname">description</td><td>Pointer to the variable where the description of the type will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check coda_errno). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gac0b43d87786bce79d957df5b9a02d7b5" name="gac0b43d87786bce79d957df5b9a02d7b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0b43d87786bce79d957df5b9a02d7b5">&#9670;&#160;</a></span>coda_type_get_fixed_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_type_get_fixed_value </td>
          <td>(</td>
          <td class="paramtype">const coda_type *</td>          <td class="paramname"><span class="paramname"><em>type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>fixed_value</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the associated fixed value string of a type if it has one. Fixed values will only occur for <a class="el" href="#ggaa4d9bef64d23de166a5e0249504f5afaa11d9a0b0ca20c41c9b6ebd492ffd3e0a">coda_text_class</a> and <a class="el" href="#ggaa4d9bef64d23de166a5e0249504f5afaa70337e3bf4f60b59f028b2b33f62f708">coda_raw_class</a> types and only for ascii, binary, or xml formatted data (in all other cases a NULL pointer will be returned). It is possible to pass a NULL pointer for the length parameter to omit the retrieval of the length. If the type does not have a fixed value a NULL pointer will be returned and the <em>length</em> parameter (if it is not a NULL pointer) will be set to 0. For ascii and xml data the <em>fixed_value</em> will be a 0 terminated string. For binary data there will not be a 0 termination character. Since fixed values for raw data can contain \0 values you should use the returned <em>length</em> parameter to determine the size of the fixed value. The <em>length</em> parameter will contain the length of the fixed value without taking a terminating '\0' into account. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>CODA type. </td></tr>
    <tr><td class="paramname">fixed_value</td><td>Pointer to the variable where the pointer to the fixed value for the type will be stored. </td></tr>
    <tr><td class="paramname">length</td><td>Pointer to the variable where the string length of the fixed value will be stored (can be NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check coda_errno). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gadd578623f4a02d0132abe2ff81bab1bd" name="gadd578623f4a02d0132abe2ff81bab1bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd578623f4a02d0132abe2ff81bab1bd">&#9670;&#160;</a></span>coda_type_get_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_type_get_format </td>
          <td>(</td>
          <td class="paramtype">const coda_type *</td>          <td class="paramname"><span class="paramname"><em>type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">coda_format *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the storage format of a type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>CODA type. </td></tr>
    <tr><td class="paramname">format</td><td>Pointer to a variable where the format will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check coda_errno). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga425a037707b53156011570572cc66455" name="ga425a037707b53156011570572cc66455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga425a037707b53156011570572cc66455">&#9670;&#160;</a></span>coda_type_get_format_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * coda_type_get_format_name </td>
          <td>(</td>
          <td class="paramtype">coda_format</td>          <td class="paramname"><span class="paramname"><em>format</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the name of a storage format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>CODA storage format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the format is known a string containing the name of the format, otherwise the string "unknown". </dd></dl>

</div>
</div>
<a id="gaac7335f81e32f69ac6d207d02a822091" name="gaac7335f81e32f69ac6d207d02a822091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac7335f81e32f69ac6d207d02a822091">&#9670;&#160;</a></span>coda_type_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_type_get_name </td>
          <td>(</td>
          <td class="paramtype">const coda_type *</td>          <td class="paramname"><span class="paramname"><em>type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the name of a type. A type can have an optional name that uniquely defines it within a product class. This is something that is used internally within CODA to allow reuse of type definitions. If a type has a name, only a single instance of the definition will be used for all places where the type is used (i.e. a single coda_type object will be used for all cases where this type is used). For this reason type names are unique within the scope of a product class. You should never rely in your code on types having a specific name, or having a name at all. The internal type reuse approach within a product class may change unannounced. If the type is unnamed a NULL pointer will be returned. The <em>name</em> parameter will either be a NULL pointer or a 0 terminated string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>CODA type. </td></tr>
    <tr><td class="paramname">name</td><td>Pointer to the variable where the name of the type will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check coda_errno). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga7dff55e12a0535bfde803fb68fb68a2e" name="ga7dff55e12a0535bfde803fb68fb68a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7dff55e12a0535bfde803fb68fb68a2e">&#9670;&#160;</a></span>coda_type_get_native_type_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * coda_type_get_native_type_name </td>
          <td>(</td>
          <td class="paramtype">coda_native_type</td>          <td class="paramname"><span class="paramname"><em>native_type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the name of a native type. In case the native type is not recognised the string "unknown" is returned. </p><dl class="section note"><dt>Note</dt><dd>Mind that there is also a special native type <a class="el" href="#gga29df10be1deb83bcf6ec8ea6064cfe46a7844219b3368ea30745c55cefdf239d6">coda_native_type_not_available</a> which will result in the string 'N/A'. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">native_type</td><td>CODA native type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the native type is known a string containing the name of the native type, otherwise the string "unknown". </dd></dl>

</div>
</div>
<a id="gafbb031cb93c024b82f5a465c6da5e969" name="gafbb031cb93c024b82f5a465c6da5e969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbb031cb93c024b82f5a465c6da5e969">&#9670;&#160;</a></span>coda_type_get_num_record_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_type_get_num_record_fields </td>
          <td>(</td>
          <td class="paramtype">const coda_type *</td>          <td class="paramname"><span class="paramname"><em>type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *</td>          <td class="paramname"><span class="paramname"><em>num_fields</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of fields of a record type. If the type is not a record class the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>CODA type. </td></tr>
    <tr><td class="paramname">num_fields</td><td>Pointer to a variable where the number of fields will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check coda_errno). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gae851e4b1832b37f4fe8f25e4a7485ebe" name="gae851e4b1832b37f4fe8f25e4a7485ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae851e4b1832b37f4fe8f25e4a7485ebe">&#9670;&#160;</a></span>coda_type_get_read_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_type_get_read_type </td>
          <td>(</td>
          <td class="paramtype">const coda_type *</td>          <td class="paramname"><span class="paramname"><em>type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">coda_native_type *</td>          <td class="paramname"><span class="paramname"><em>read_type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the best native type for reading data of a CODA type. The native type that is returned indicates which storage type can best be used when reading data of this CODA type to memory. Compound types (arrays and records) that can be read directly (using a raw byte array) will return a read type <a class="el" href="#gga29df10be1deb83bcf6ec8ea6064cfe46a22f9a7f98b86d624663b93c68efc6227">coda_native_type_bytes</a>. If a type can not be read directly (e.g. compound types in XML, netCDF, HDF4, and HDF5 products) the special native type value <a class="el" href="#gga29df10be1deb83bcf6ec8ea6064cfe46a7844219b3368ea30745c55cefdf239d6">coda_native_type_not_available</a> will be returned. </p><dl class="section note"><dt>Note</dt><dd>Be aware that types of class <a class="el" href="#ggaa4d9bef64d23de166a5e0249504f5afaa7b0a5823955f5cd50c723fde30432a5b">coda_integer_class</a> can return a native type <a class="el" href="#gga29df10be1deb83bcf6ec8ea6064cfe46abfb0ef3b4696c83d742bbe44f9c6ec48">coda_native_type_double</a> if the integer type has a conversion associated with it and conversions are enabled. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__coda__general.html#ga5b9aba6faa0583c70bdcd9add6e72cae">coda_set_option_perform_conversions()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>CODA type. </td></tr>
    <tr><td class="paramname">read_type</td><td>Pointer to a variable where the native type for reading will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check coda_errno). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga7f6b27b66e48f2c1482f825102a24eca" name="ga7f6b27b66e48f2c1482f825102a24eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f6b27b66e48f2c1482f825102a24eca">&#9670;&#160;</a></span>coda_type_get_record_field_available_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_type_get_record_field_available_status </td>
          <td>(</td>
          <td class="paramtype">const coda_type *</td>          <td class="paramname"><span class="paramname"><em>type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>available</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the available status of a record field. If the type is not a record class the function will return an error. The available status is only applicable for data in ascii, binary, or XML format (fields are always available for netCDF, HDF4, and HDF5 data). The available status is a dynamic property and can thus only really be determined using the function <a class="el" href="group__coda__cursor.html#gae98f5d50feff40682072978674ca11ae">coda_cursor_get_record_field_available_status()</a>. The <a class="el" href="#ga69a9241c8968e8f176a66d96bc4761ad">coda_type_get_record_field_hidden_status()</a> function, however, indicates whether the availability of a field is dynamic or not. If it is not dynamic (i.e. it is always available) <em>available</em> will be 1, if not (i.e. it has to be determined dynamically) <em>available</em> will be -1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>CODA type. </td></tr>
    <tr><td class="paramname">index</td><td>Field index (0 &lt;= <em>index</em> &lt; number of fields). </td></tr>
    <tr><td class="paramname">available</td><td>Pointer to the variable where the available status of the record field will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check coda_errno). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga69a9241c8968e8f176a66d96bc4761ad" name="ga69a9241c8968e8f176a66d96bc4761ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69a9241c8968e8f176a66d96bc4761ad">&#9670;&#160;</a></span>coda_type_get_record_field_hidden_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_type_get_record_field_hidden_status </td>
          <td>(</td>
          <td class="paramtype">const coda_type *</td>          <td class="paramname"><span class="paramname"><em>type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>hidden</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the hidden status of a record field. If the type is not a record class the function will return an error. The hidden property is only applicable for ascii, binary, and xml data (fields can not be hidden for other formats). If the record field has the hidden property <em>hidden</em> will be set to 1, otherwise it will be set to 0. </p><dl class="section note"><dt>Note</dt><dd>The C API of CODA does not hide record fields itself. This property is used by interfaces on top of the CODA C interface (such as the MATLAB and IDL interfaces) to eliminate hidden fields when retrieving complete records. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>CODA type. </td></tr>
    <tr><td class="paramname">index</td><td>Field index (0 &lt;= <em>index</em> &lt; number of fields). </td></tr>
    <tr><td class="paramname">hidden</td><td>Pointer to the variable where the hidden status of the record field will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check coda_errno). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga9d09c82ae9fe49493b627303cbd30a1e" name="ga9d09c82ae9fe49493b627303cbd30a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d09c82ae9fe49493b627303cbd30a1e">&#9670;&#160;</a></span>coda_type_get_record_field_index_from_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_type_get_record_field_index_from_name </td>
          <td>(</td>
          <td class="paramtype">const coda_type *</td>          <td class="paramname"><span class="paramname"><em>type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the field index from a field name for a record type. If the type is not a record class the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>CODA type. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the record field. </td></tr>
    <tr><td class="paramname">index</td><td>Pointer to a variable where the field index will be stored (0 &lt;= <em>index</em> &lt; number of fields). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check coda_errno). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gad9c0f013b6188abab7eee08ad8533f48" name="gad9c0f013b6188abab7eee08ad8533f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9c0f013b6188abab7eee08ad8533f48">&#9670;&#160;</a></span>coda_type_get_record_field_index_from_real_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_type_get_record_field_index_from_real_name </td>
          <td>(</td>
          <td class="paramtype">const coda_type *</td>          <td class="paramname"><span class="paramname"><em>type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>real_name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the field index based on the 'real name' of the field for a record type. If the type is not a record class the function will return an error. If a field has no explicit 'real name' set, a match against the regular field name will be performed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>CODA type. </td></tr>
    <tr><td class="paramname">real_name</td><td>Real name of the record field. </td></tr>
    <tr><td class="paramname">index</td><td>Pointer to a variable where the field index will be stored (0 &lt;= <em>index</em> &lt; number of fields). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check coda_errno). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gac00e6ae545d1f81ca19d15e8be2027a9" name="gac00e6ae545d1f81ca19d15e8be2027a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac00e6ae545d1f81ca19d15e8be2027a9">&#9670;&#160;</a></span>coda_type_get_record_field_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_type_get_record_field_name </td>
          <td>(</td>
          <td class="paramtype">const coda_type *</td>          <td class="paramname"><span class="paramname"><em>type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the name of a record field. If the type is not a record class the function will return an error. The <em>name</em> parameter will be 0 terminated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>CODA type. </td></tr>
    <tr><td class="paramname">index</td><td>Field index (0 &lt;= <em>index</em> &lt; number of fields). </td></tr>
    <tr><td class="paramname">name</td><td>Pointer to the variable where the name of the record field will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check coda_errno). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga075a805485da07db1480a38b988175ec" name="ga075a805485da07db1480a38b988175ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga075a805485da07db1480a38b988175ec">&#9670;&#160;</a></span>coda_type_get_record_field_real_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_type_get_record_field_real_name </td>
          <td>(</td>
          <td class="paramtype">const coda_type *</td>          <td class="paramname"><span class="paramname"><em>type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>real_name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the unaltered name of a record field. The real name of a field is the name of the field without the identifier restriction. For (partially) self-describing formats such as XML, HDF, and netCDF, the name of a field as used by CODA will actually be a conversion of the name of the stored element to something that conforms to the rules of an identifier (i.e. only allowing a-z, A-Z, 0-9 and underscores characters and names have to start with an alpha character). The real name property of a field represents the original name of the element (e.g. XML element name, HDF5 DataSet name, netCDF variable name, etc.). If the concept of a real name does not apply, this function will return the same result as <a class="el" href="#gac00e6ae545d1f81ca19d15e8be2027a9">coda_type_get_record_field_name()</a>.</p>
<p>If the type is not a record class the function will return an error. The <em>real_name</em> parameter will be 0 terminated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>CODA type. </td></tr>
    <tr><td class="paramname">index</td><td>Field index (0 &lt;= <em>index</em> &lt; number of fields). </td></tr>
    <tr><td class="paramname">real_name</td><td>Pointer to the variable where the real name of the record field will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check coda_errno). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga9d857c5b8a203b23e40e6be4f0e651c0" name="ga9d857c5b8a203b23e40e6be4f0e651c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d857c5b8a203b23e40e6be4f0e651c0">&#9670;&#160;</a></span>coda_type_get_record_field_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_type_get_record_field_type </td>
          <td>(</td>
          <td class="paramtype">const coda_type *</td>          <td class="paramname"><span class="paramname"><em>type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">coda_type **</td>          <td class="paramname"><span class="paramname"><em>field_type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the CODA type for a record field. If the type is not a record class the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>CODA type. </td></tr>
    <tr><td class="paramname">index</td><td>Field index (0 &lt;= <em>index</em> &lt; number of fields). </td></tr>
    <tr><td class="paramname">field_type</td><td>Pointer to the variable where the type of the record field will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check coda_errno). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga6d6624197f226411f0b063ab3eb554b2" name="ga6d6624197f226411f0b063ab3eb554b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d6624197f226411f0b063ab3eb554b2">&#9670;&#160;</a></span>coda_type_get_record_union_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_type_get_record_union_status </td>
          <td>(</td>
          <td class="paramtype">const coda_type *</td>          <td class="paramname"><span class="paramname"><em>type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>is_union</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the union status of a record. If the record is a union (i.e. all fields are dynamically available and only one field can be available at any time) <em>is_union</em> will be set to 1, otherwise it will be set to 0. If the type is not a record class the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>CODA type. </td></tr>
    <tr><td class="paramname">is_union</td><td>Pointer to a variable where the union status will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check coda_errno). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga693a083ef0514742a4eedcc432a1dd6b" name="ga693a083ef0514742a4eedcc432a1dd6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga693a083ef0514742a4eedcc432a1dd6b">&#9670;&#160;</a></span>coda_type_get_special_base_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_type_get_special_base_type </td>
          <td>(</td>
          <td class="paramtype">const coda_type *</td>          <td class="paramname"><span class="paramname"><em>type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">coda_type **</td>          <td class="paramname"><span class="paramname"><em>base_type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the base type for a special type. If the type is not a special type the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>CODA type. </td></tr>
    <tr><td class="paramname">base_type</td><td>Pointer to the variable where the base type will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check coda_errno). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gad1fb786cae51605b82ed6f93bd69172e" name="gad1fb786cae51605b82ed6f93bd69172e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1fb786cae51605b82ed6f93bd69172e">&#9670;&#160;</a></span>coda_type_get_special_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_type_get_special_type </td>
          <td>(</td>
          <td class="paramtype">const coda_type *</td>          <td class="paramname"><span class="paramname"><em>type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">coda_special_type *</td>          <td class="paramname"><span class="paramname"><em>special_type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the special type for a type. This function will return the specific special type for types of class <a class="el" href="#ggaa4d9bef64d23de166a5e0249504f5afaa5d605b83d52f350f6525d9ee8576f34f">coda_special_class</a>. If the type is not a special type the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>CODA type. </td></tr>
    <tr><td class="paramname">special_type</td><td>Pointer to a variable where the special type will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check coda_errno). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga9530373dbbdb5def369f247c9f773178" name="ga9530373dbbdb5def369f247c9f773178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9530373dbbdb5def369f247c9f773178">&#9670;&#160;</a></span>coda_type_get_special_type_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * coda_type_get_special_type_name </td>
          <td>(</td>
          <td class="paramtype">coda_special_type</td>          <td class="paramname"><span class="paramname"><em>special_type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the name of a special type. In case the special type is not recognised the string "unknown" is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">special_type</td><td>CODA special type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the special type is known a string containing the name of the special type, otherwise the string "unknown". </dd></dl>

</div>
</div>
<a id="ga20e53281d64b697447f0dfc4411fdce8" name="ga20e53281d64b697447f0dfc4411fdce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20e53281d64b697447f0dfc4411fdce8">&#9670;&#160;</a></span>coda_type_get_string_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_type_get_string_length </td>
          <td>(</td>
          <td class="paramtype">const coda_type *</td>          <td class="paramname"><span class="paramname"><em>type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the length in bytes of a string data type. If the type does not refer to text data the function will return an error. If the size is not fixed and can only be determined from information inside a product then <em>length</em> will be set to -1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>CODA type. </td></tr>
    <tr><td class="paramname">length</td><td>Pointer to a variable where the string length (not including terminating 0) will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check coda_errno). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gacc3e3c3c022db1100473a76d407e83c2" name="gacc3e3c3c022db1100473a76d407e83c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc3e3c3c022db1100473a76d407e83c2">&#9670;&#160;</a></span>coda_type_get_unit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_type_get_unit </td>
          <td>(</td>
          <td class="paramtype">const coda_type *</td>          <td class="paramname"><span class="paramname"><em>type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>unit</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the unit of a type. You will only receive unit information for ascii, binary, and xml data (for other formats a NULL pointer will be returned). The unit information is a string with the same text as can be found in the unit column of the CODA Product Format Definition documentation for this type. If you try to retrieve the unit for an array type then the unit of its base type will be returned. The <em>unit</em> parameter will either be a NULL pointer or a 0 terminated string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>CODA type. </td></tr>
    <tr><td class="paramname">unit</td><td>Pointer to the variable where the unit information of the type will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check coda_errno). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga682a957fd2ba53edbab6219394cbf7d3" name="ga682a957fd2ba53edbab6219394cbf7d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga682a957fd2ba53edbab6219394cbf7d3">&#9670;&#160;</a></span>coda_type_has_attributes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_type_has_attributes </td>
          <td>(</td>
          <td class="paramtype">const coda_type *</td>          <td class="paramname"><span class="paramname"><em>type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>has_attributes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine whether the type has any attributes. If the record returned by <a class="el" href="#ga10d2b4f9c483cc50f645f36246738e47">coda_type_get_attributes()</a> has one or more fields then <em>has_attributes</em> will be set to 1, otherwise it will be set to 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>CODA type. </td></tr>
    <tr><td class="paramname">has_attributes</td><td>Pointer to the variable where attribute availability status will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check coda_errno). </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
<div class="footer">
<hr><p>Copyright &copy; 2007-2022 <b>s<span class="soft-red">[</span>&amp;<span class="soft-red">]</span>t</b>, The Netherlands.
</p>
</div>
</div>
</body>
</html>
