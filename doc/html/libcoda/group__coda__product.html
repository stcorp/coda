<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>CODA Product</title>
<link href="../css/codadoc.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
</head>
<body>
<div class="wide">
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp;
<a class="qindex" href="modules.html">Modules</a> &nbsp;
</center>
<hr>
<!-- Generated by Doxygen 1.9.2 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">CODA Product</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaaf31b4b329a9b03d6e7e7a386c466cf6"><td class="memItemLeft" align="right" valign="top">typedef struct coda_product_struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a></td></tr>
<tr class="separator:gaaf31b4b329a9b03d6e7e7a386c466cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0bdc413edf6e76ca93fc70d20396cc05"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__product.html#ga0bdc413edf6e76ca93fc70d20396cc05">coda_recognize_file</a> (const char *filename, int64_t *file_size, <a class="el" href="group__coda__general.html#ga8e2552c6f87737610ef2bcce876e9e06">coda_format</a> *file_format, const char **product_class, const char **product_type, int *version)</td></tr>
<tr class="separator:ga0bdc413edf6e76ca93fc70d20396cc05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f6c7522db4933704d582c6b98e9d1aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__product.html#ga6f6c7522db4933704d582c6b98e9d1aa">coda_open</a> (const char *filename, <a class="el" href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a> **product)</td></tr>
<tr class="separator:ga6f6c7522db4933704d582c6b98e9d1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2438f89fc6778991964272b474c99746"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__product.html#ga2438f89fc6778991964272b474c99746">coda_open_as</a> (const char *filename, const char *product_class, const char *product_type, int version, <a class="el" href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a> **product)</td></tr>
<tr class="separator:ga2438f89fc6778991964272b474c99746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad81f6fd1300679fe3715d78953d96cc8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__product.html#gad81f6fd1300679fe3715d78953d96cc8">coda_close</a> (<a class="el" href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a> *product)</td></tr>
<tr class="separator:gad81f6fd1300679fe3715d78953d96cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa42f2abe49219e8c637b5b58ffbe2da2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__product.html#gaa42f2abe49219e8c637b5b58ffbe2da2">coda_get_product_filename</a> (const <a class="el" href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a> *product, const char **filename)</td></tr>
<tr class="separator:gaa42f2abe49219e8c637b5b58ffbe2da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73c3c00e98f984702d383efff3b38dfd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__product.html#ga73c3c00e98f984702d383efff3b38dfd">coda_get_product_file_size</a> (const <a class="el" href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a> *product, int64_t *file_size)</td></tr>
<tr class="separator:ga73c3c00e98f984702d383efff3b38dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c4c0b386994015dc7e300e0ac4a5885"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__product.html#ga4c4c0b386994015dc7e300e0ac4a5885">coda_get_product_format</a> (const <a class="el" href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a> *product, <a class="el" href="group__coda__general.html#ga8e2552c6f87737610ef2bcce876e9e06">coda_format</a> *format)</td></tr>
<tr class="separator:ga4c4c0b386994015dc7e300e0ac4a5885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa77ad3e76bee6fa0eb5339ed1136ee4c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__product.html#gaa77ad3e76bee6fa0eb5339ed1136ee4c">coda_get_product_class</a> (const <a class="el" href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a> *product, const char **product_class)</td></tr>
<tr class="separator:gaa77ad3e76bee6fa0eb5339ed1136ee4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c4c5e20e2ad0313692c92bd56246fcc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__product.html#ga7c4c5e20e2ad0313692c92bd56246fcc">coda_get_product_type</a> (const <a class="el" href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a> *product, const char **product_type)</td></tr>
<tr class="separator:ga7c4c5e20e2ad0313692c92bd56246fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e06739ae57f13334980d14791dec8b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__product.html#ga7e06739ae57f13334980d14791dec8b8">coda_get_product_version</a> (const <a class="el" href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a> *product, int *version)</td></tr>
<tr class="separator:ga7e06739ae57f13334980d14791dec8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga770e361044cef942914c888c67bab04a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__product.html#ga770e361044cef942914c888c67bab04a">coda_get_product_root_type</a> (const <a class="el" href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a> *product, <a class="el" href="group__coda__types.html#ga1b591a7c6147d5785a0257a8b6fbc864">coda_type</a> **type)</td></tr>
<tr class="separator:ga770e361044cef942914c888c67bab04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b1a758971410616dc60d3049e633307"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__product.html#ga4b1a758971410616dc60d3049e633307">coda_get_product_definition_file</a> (const <a class="el" href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a> *product, const char **definition_file)</td></tr>
<tr class="separator:ga4b1a758971410616dc60d3049e633307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd8d9021940dedee89ee3baa7e12a36d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__product.html#gacd8d9021940dedee89ee3baa7e12a36d">coda_get_product_variable_value</a> (<a class="el" href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a> *product, const char *variable, long index, int64_t *value)</td></tr>
<tr class="separator:gacd8d9021940dedee89ee3baa7e12a36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >The CODA Product module contains functions and procedures to open, close and retrieve information about product files that are supported by CODA.</p>
<p >Under the hood CODA uses several different backends to access data from products. There are backends for structured ascii, structured binary, XML, netCDF, HDF4, HDF5, and several other data formats. Some formats such as netCDF, HDF4, and HDF5 are self describing product formats. This means that CODA will retrieve information about the structural layout and contents from the file itself. For other formats, such as XML, CODA can either use an external definition (from a .codadef file) to interpret an XML file (similar like an XML Schema) or it can try to retrieve structural layout of the file from the file itself. For XML this last option will result in a reduced form of access, since 'leaf elements' can not be interpreted as e.g. integer/float/time but will only be accessible as string data. For the interpretation of structured ascii and structured binary files (or a combination of both) CODA purely relies on the format definitions that are provided in the .codadef files.</p>
<p >In order to be able to open product files with CODA you will first have to initialize CODA with <a class="el" href="group__coda__general.html#ga8e7601eb0f115a4052e4af96668b3429">coda_init()</a> (see <a class="el" href="group__coda__general.html">CODA General</a>). This initialization routine will initialize all available backends and will search for all .codadef files in your CODA definition path to read the necessary descriptions of all non self-describing products (note that you want to use .codadef files, you will need to have set the location of your CODA definition path using <a class="el" href="group__coda__general.html#ga4a7e44bcb241c93a6b29e4c7f8cecadb">coda_set_definition_path()</a> or via the CODA_DEFINITION environment variable before calling <a class="el" href="group__coda__general.html#ga8e7601eb0f115a4052e4af96668b3429">coda_init()</a>). As a user you can access all supported products in the same way no matter which format the product uses underneath. This means that you can use the same functions for opening, traversing, reading, and closing a product no matter whether you are accessing an ascii, binary, XML, netCDF, HDF4, HDF5, etc. formatted file.</p>
<p >To open a product file you will have to use the <a class="el" href="group__coda__product.html#ga6f6c7522db4933704d582c6b98e9d1aa">coda_open()</a> function. This function takes as only parameter the filename of the product file. CODA will then open the file and automatically check what type of file it is. If it is an HDF4 or HDF5 file it will use the HDF4/HDF5 backends for further access. In all other cases CODA will consult the data dictionary to determine whether there is a product definition for that file in one of the available product classes.</p>
<p >Within CODA a product class is a grouping of related product types. Usually all data products for a single satellite mission belong to the same product class. Within a product class there can be several product types and each product type can have multiple versions of its format (this is because product format descriptions will sometimes change during the lifetime of a product type). The combination of product class, product type and product version number uniquely defines the description that will be used to interpret a product file.</p>
<p >If CODA can not determine the product class, type, or version of a structured ascii/binary file, the file will not be opened and an error will be returned. For other formats such as XML, netCDF, HDF4, and HDF5 files CODA will open and interpret the data based on the file contents. If everything was successful, the <a class="el" href="group__coda__product.html#ga6f6c7522db4933704d582c6b98e9d1aa">coda_open()</a> function will provide you a file handle (of type <a class="el" href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a>) that can be passed to a range of other functions to retrieve information like the product class, type and version, or to read data from the file with the help of CODA cursors (see <a class="el" href="group__coda__cursor.html">CODA Cursor</a>). After you are done with a file you should close it with <a class="el" href="group__coda__product.html#gad81f6fd1300679fe3715d78953d96cc8">coda_close()</a>. This function will also free the memory that was allocated for the file handle by <a class="el" href="group__coda__product.html#ga6f6c7522db4933704d582c6b98e9d1aa">coda_open()</a>. Below is a simple example that opens a file called productfile.dat and closes it again. </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a> *product;</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__coda__general.html#ga8e7601eb0f115a4052e4af96668b3429">coda_init</a>() != 0)</div>
<div class="line">{</div>
<div class="line">    fprintf(stderr, <span class="stringliteral">&quot;Error: %s\n&quot;</span>, <a class="code hl_function" href="group__coda__error.html#ga096abc50f7fa98cf3a2f3210c54570e8">coda_errno_to_string</a>(<a class="code hl_variable" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>));</div>
<div class="line">    exit(1);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__coda__product.html#ga6f6c7522db4933704d582c6b98e9d1aa">coda_open</a>(<span class="stringliteral">&quot;productfile.dat&quot;</span>, &amp;product) != 0)</div>
<div class="line">{</div>
<div class="line">    fprintf(stderr, <span class="stringliteral">&quot;Error: %s\n&quot;</span>, <a class="code hl_function" href="group__coda__error.html#ga096abc50f7fa98cf3a2f3210c54570e8">coda_errno_to_string</a>(<a class="code hl_variable" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>));</div>
<div class="line">    exit(1);</div>
<div class="line">}</div>
<div class="line"><a class="code hl_function" href="group__coda__product.html#gad81f6fd1300679fe3715d78953d96cc8">coda_close</a>(product);</div>
<div class="line"><a class="code hl_function" href="group__coda__general.html#gaf238ffee3073c81b6e80fb03d9968386">coda_done</a>();</div>
<div class="ttc" id="agroup__coda__error_html_ga096abc50f7fa98cf3a2f3210c54570e8"><div class="ttname"><a href="group__coda__error.html#ga096abc50f7fa98cf3a2f3210c54570e8">coda_errno_to_string</a></div><div class="ttdeci">const char * coda_errno_to_string(int err)</div><div class="ttdef"><b>Definition:</b> coda-errno.c:282</div></div>
<div class="ttc" id="agroup__coda__error_html_gafcb445c7fcab2d4d0af01f0e1c2dc866"><div class="ttname"><a href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a></div><div class="ttdeci">THREAD_LOCAL int coda_errno</div><div class="ttdef"><b>Definition:</b> coda-errno.c:159</div></div>
<div class="ttc" id="agroup__coda__general_html_ga8e7601eb0f115a4052e4af96668b3429"><div class="ttname"><a href="group__coda__general.html#ga8e7601eb0f115a4052e4af96668b3429">coda_init</a></div><div class="ttdeci">int coda_init(void)</div><div class="ttdef"><b>Definition:</b> coda.c:484</div></div>
<div class="ttc" id="agroup__coda__general_html_gaf238ffee3073c81b6e80fb03d9968386"><div class="ttname"><a href="group__coda__general.html#gaf238ffee3073c81b6e80fb03d9968386">coda_done</a></div><div class="ttdeci">void coda_done(void)</div><div class="ttdef"><b>Definition:</b> coda.c:555</div></div>
<div class="ttc" id="agroup__coda__product_html_ga6f6c7522db4933704d582c6b98e9d1aa"><div class="ttname"><a href="group__coda__product.html#ga6f6c7522db4933704d582c6b98e9d1aa">coda_open</a></div><div class="ttdeci">int coda_open(const char *filename, coda_product **product)</div><div class="ttdef"><b>Definition:</b> coda-product.c:658</div></div>
<div class="ttc" id="agroup__coda__product_html_gaaf31b4b329a9b03d6e7e7a386c466cf6"><div class="ttname"><a href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a></div><div class="ttdeci">struct coda_product_struct coda_product</div><div class="ttdef"><b>Definition:</b> coda.h:325</div></div>
<div class="ttc" id="agroup__coda__product_html_gad81f6fd1300679fe3715d78953d96cc8"><div class="ttname"><a href="group__coda__product.html#gad81f6fd1300679fe3715d78953d96cc8">coda_close</a></div><div class="ttdeci">int coda_close(coda_product *product)</div><div class="ttdef"><b>Definition:</b> coda-product.c:770</div></div>
</div><!-- fragment --><p >It is possible to have multiple product files open at the same time. Just call <a class="el" href="group__coda__product.html#ga6f6c7522db4933704d582c6b98e9d1aa">coda_open()</a> again on a different file and you will get a new file handle. It is also possible to open a single product file multiple times (although this is a feature we encourage you to avoid on 32-bit systems because of the mmap() limitations - see <a class="el" href="group__coda__general.html#ga1c56d546f9056be24e193b24264b8f1d">coda_set_option_use_mmap()</a>). In that case CODA will just return a second product file handle which is completely independent of the first product file handle you already had. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaaf31b4b329a9b03d6e7e7a386c466cf6" name="gaaf31b4b329a9b03d6e7e7a386c466cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf31b4b329a9b03d6e7e7a386c466cf6">&#9670;&nbsp;</a></span>coda_product</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >CODA Product handle </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad81f6fd1300679fe3715d78953d96cc8" name="gad81f6fd1300679fe3715d78953d96cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad81f6fd1300679fe3715d78953d96cc8">&#9670;&nbsp;</a></span>coda_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a> *&#160;</td>
          <td class="paramname"><em>product</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Close an open product file. This function will close the file associated with the file handle and release the memory for the handle. The file handle will be released even if unmapping or closing of the product file produced an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">product</td><td>Pointer to a product file handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaa77ad3e76bee6fa0eb5339ed1136ee4c" name="gaa77ad3e76bee6fa0eb5339ed1136ee4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa77ad3e76bee6fa0eb5339ed1136ee4c">&#9670;&nbsp;</a></span>coda_get_product_class()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_get_product_class </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a> *&#160;</td>
          <td class="paramname"><em>product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>product_class</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the product class of a product file. This function will return the name of the product class of a product. The name of the product class will be stored in the <em>product_class</em> parameter and will be 0 terminated. The string pointer that is returned for <em>product_class</em> does not have to be freed by the user and will remain valid until <a class="el" href="group__coda__general.html#gaf238ffee3073c81b6e80fb03d9968386">coda_done()</a> is called. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">product</td><td>Pointer to a product file handle. </td></tr>
    <tr><td class="paramname">product_class</td><td>Pointer to the variable where the class name of the product will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga4b1a758971410616dc60d3049e633307" name="ga4b1a758971410616dc60d3049e633307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b1a758971410616dc60d3049e633307">&#9670;&nbsp;</a></span>coda_get_product_definition_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_get_product_definition_file </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a> *&#160;</td>
          <td class="paramname"><em>product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>definition_file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get path to the coda definition file that describes the format for this product. This function will return a full path to the coda definition (.codadef) file that contains the format description for this product. If the format is not taken from an external coda definition description but based on the self-describing format information from the file itself or based on a hardcoded format definition within one of the coda backends then <em>definition_file</em> will be set to NULL. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">product</td><td>Pointer to a product file handle. </td></tr>
    <tr><td class="paramname">definition_file</td><td>Pointer to the variable where the path to used coda definition file will be stored (or NULL if not applicable). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga73c3c00e98f984702d383efff3b38dfd" name="ga73c3c00e98f984702d383efff3b38dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73c3c00e98f984702d383efff3b38dfd">&#9670;&nbsp;</a></span>coda_get_product_file_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_get_product_file_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a> *&#160;</td>
          <td class="paramname"><em>product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>file_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the actual file size of a product file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">product</td><td>Pointer to a product file handle. </td></tr>
    <tr><td class="paramname">file_size</td><td>Pointer to the variable where the actual file size (in bytes) of the product is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaa42f2abe49219e8c637b5b58ffbe2da2" name="gaa42f2abe49219e8c637b5b58ffbe2da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa42f2abe49219e8c637b5b58ffbe2da2">&#9670;&nbsp;</a></span>coda_get_product_filename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_get_product_filename </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a> *&#160;</td>
          <td class="paramname"><em>product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the filename of a product file. This function returns the same name that was used in the <a class="el" href="group__coda__product.html#ga6f6c7522db4933704d582c6b98e9d1aa">coda_open()</a> call for this product file. The pointer to the filename string is valid as long as the file is open. When you call <a class="el" href="group__coda__product.html#gad81f6fd1300679fe3715d78953d96cc8">coda_close()</a> on the product file the filename string will automatically be removed and the pointer that will be stored in <em>filename</em> will become invalid. The name of the product file will be stored in the <em>filename</em> parameter and will be 0 terminated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">product</td><td>Pointer to a product file handle. </td></tr>
    <tr><td class="paramname">filename</td><td>Pointer to the variable where the filename of the product will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga4c4c0b386994015dc7e300e0ac4a5885" name="ga4c4c0b386994015dc7e300e0ac4a5885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c4c0b386994015dc7e300e0ac4a5885">&#9670;&nbsp;</a></span>coda_get_product_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_get_product_format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a> *&#160;</td>
          <td class="paramname"><em>product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__coda__general.html#ga8e2552c6f87737610ef2bcce876e9e06">coda_format</a> *&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the basic file format of the product. Possible formats are ascii, binary, xml, netcdf, grib, hdf4, cdf, and hdf5. Mind that inside a product different typed data can exist. For instance, both xml and binary products can have part of their content be ascii typed data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">product</td><td>Pointer to a product file handle. </td></tr>
    <tr><td class="paramname">format</td><td>Pointer to the variable where the format will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga770e361044cef942914c888c67bab04a" name="ga770e361044cef942914c888c67bab04a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga770e361044cef942914c888c67bab04a">&#9670;&nbsp;</a></span>coda_get_product_root_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_get_product_root_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a> *&#160;</td>
          <td class="paramname"><em>product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__coda__types.html#ga1b591a7c6147d5785a0257a8b6fbc864">coda_type</a> **&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the CODA type of the root of the product. For self-describing data formats the definition from the codadef file will be returned if it exists, otherwise the definition based on the format as extracted from the product itself will be returned.</p>
<p >Note that for self-describing products with a codadef definition (except for xml) the product itself will always be interpreted using the definition as extracted from the product itself. The <a class="el" href="group__coda__product.html#ga770e361044cef942914c888c67bab04a">coda_get_product_root_type()</a> function is then the means to retrieve the definition from the codadef and calling <a class="el" href="group__coda__cursor.html#ga6f9f142b7b7adc422587f08bd9c17e07">coda_cursor_get_type()</a> for a cursor that points to the root of the product will return the definition as extracted from the product.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">product</td><td>Pointer to a product file handle. </td></tr>
    <tr><td class="paramname">type</td><td>Pointer to the variable where the Type handle will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga7c4c5e20e2ad0313692c92bd56246fcc" name="ga7c4c5e20e2ad0313692c92bd56246fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c4c5e20e2ad0313692c92bd56246fcc">&#9670;&nbsp;</a></span>coda_get_product_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_get_product_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a> *&#160;</td>
          <td class="paramname"><em>product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>product_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the product type of a product file. This function will return the name of the product type of a product. The name of the product type will be stored in the <em>product_type</em> parameter and will be 0 terminated. The string pointer that is returned for <em>product_type</em> does not have to be freed by the user and will remain valid until <a class="el" href="group__coda__general.html#gaf238ffee3073c81b6e80fb03d9968386">coda_done()</a> is called. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">product</td><td>Pointer to a product file handle. </td></tr>
    <tr><td class="paramname">product_type</td><td>Pointer to the variable where the product type name of the product will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gacd8d9021940dedee89ee3baa7e12a36d" name="gacd8d9021940dedee89ee3baa7e12a36d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd8d9021940dedee89ee3baa7e12a36d">&#9670;&nbsp;</a></span>coda_get_product_variable_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_get_product_variable_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a> *&#160;</td>
          <td class="paramname"><em>product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the value for a product variable. CODA supports a mechanism called product variables to store frequently needed information of a product (i.e. information that is needed to calculate byte offsets or array sizes within a product). With this function you can retrieve the values for those product variables (consult the CODA Product Definition Documentation for an overview of product variables for a certain product type). Product variables can be one dimensional arrays, in which case you will have to pass an array index using the <em>index</em> parameter. If the product variable is a scalar you should pass 0 for <em>index</em>. The value of a product variable is always a 64-bit integer and will be stored in <em>value</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">product</td><td>Pointer to a product file handle. </td></tr>
    <tr><td class="paramname">variable</td><td>The name of the product variable. </td></tr>
    <tr><td class="paramname">index</td><td>The array index of the product variable (pass 0 if the variable is a scalar). </td></tr>
    <tr><td class="paramname">value</td><td>Pointer to the variable where the product variable value will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga7e06739ae57f13334980d14791dec8b8" name="ga7e06739ae57f13334980d14791dec8b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e06739ae57f13334980d14791dec8b8">&#9670;&nbsp;</a></span>coda_get_product_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_get_product_version </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a> *&#160;</td>
          <td class="paramname"><em>product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the product type version of a product file. This function will return the format version number of a product. This version number is a rounded number and newer versions of a format will always have a version number that is higher than that of older formats. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">product</td><td>Pointer to a product file handle. </td></tr>
    <tr><td class="paramname">version</td><td>Pointer to the variable where the product version of the product type of the product will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga6f6c7522db4933704d582c6b98e9d1aa" name="ga6f6c7522db4933704d582c6b98e9d1aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f6c7522db4933704d582c6b98e9d1aa">&#9670;&nbsp;</a></span>coda_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_open </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a> **&#160;</td>
          <td class="paramname"><em>product</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Open a product file for reading. This function will try to open the specified file for reading. On success a newly allocated file handle will be returned. The memory for this file handle will be released when <a class="el" href="group__coda__product.html#gad81f6fd1300679fe3715d78953d96cc8">coda_close()</a> is called for this handle. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Relative or full path to the product file. </td></tr>
    <tr><td class="paramname">product</td><td>Pointer to the variable where the pointer to the product file handle will be storeed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga2438f89fc6778991964272b474c99746" name="ga2438f89fc6778991964272b474c99746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2438f89fc6778991964272b474c99746">&#9670;&nbsp;</a></span>coda_open_as()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_open_as </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>product_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>product_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a> **&#160;</td>
          <td class="paramname"><em>product</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Open a product file for reading using a specific format definition. This function will try to open the specified file for reading similar to <a class="el" href="group__coda__product.html#ga6f6c7522db4933704d582c6b98e9d1aa">coda_open()</a>, but instead of trying to automatically recognise the applicable product class/type/version as <a class="el" href="group__coda__product.html#ga6f6c7522db4933704d582c6b98e9d1aa">coda_open()</a> does, this function will impose the format definition that is associated with the given <em>product_class</em>, <em>product_type</em>, and <em>version</em> parameters. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Relative or full path to the product file. </td></tr>
    <tr><td class="paramname">product_class</td><td>Name of the product class for the requested format definition. </td></tr>
    <tr><td class="paramname">product_type</td><td>Name of the product type for the requested format definition. </td></tr>
    <tr><td class="paramname">version</td><td>Format version number of the product type definition. Use -1 to request the latest available definition. </td></tr>
    <tr><td class="paramname">product</td><td>Pointer to the variable where the pointer to the product file handle will be storeed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga0bdc413edf6e76ca93fc70d20396cc05" name="ga0bdc413edf6e76ca93fc70d20396cc05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bdc413edf6e76ca93fc70d20396cc05">&#9670;&nbsp;</a></span>coda_recognize_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_recognize_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>file_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__coda__general.html#ga8e2552c6f87737610ef2bcce876e9e06">coda_format</a> *&#160;</td>
          <td class="paramname"><em>file_format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>product_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>product_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Determine the file size, format, product class, product type, and format version of a product file. This function will perform an open and close on the product file and will try to automatically recognize the product class, type, and version of the product file. If the file is a netCDF, HDF4, or HDF5 file the <em>file_format</em> will be set, but <em>product_class</em> and <em>product_type</em> will be set to NULL and <em>version</em> will be set to -1. For XML the <em>product_class</em>, <em>product_type</em>, and <em>version</em> will only be set if there is an external definition available for the product (i.e. from one of the .codadef files in your CODA definition path). Otherwise the values will be NULL/-1. If a description of the product file is included in the data dictionary the product class, type, and version will be set according to what the automatic recognition rules have determined. The file_size will be set to the actual byte size of the file. It is possible to pass a NULL pointer for one or more of the parameters <em>file_size</em>, <em>file_format</em>, <em>product_class</em>, <em>product_type</em>, and <em>product_version</em>. If the parameter is NULL no value for this parameter is returned. The string pointers that are returned for <em>product_class</em> and <em>product_type</em> do not have to be freed by the user and will remain valid until <a class="el" href="group__coda__general.html#gaf238ffee3073c81b6e80fb03d9968386">coda_done()</a> is called. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Relative or full path to the product file. </td></tr>
    <tr><td class="paramname">file_size</td><td>Pointer to the variable where the actual file size in bytes will be stored. </td></tr>
    <tr><td class="paramname">file_format</td><td>Pointer to the variable where the file format value will be stored. </td></tr>
    <tr><td class="paramname">product_class</td><td>Pointer to the variable where the product class string will be stored. </td></tr>
    <tr><td class="paramname">product_type</td><td>Pointer to the variable where the product type string will be stored. </td></tr>
    <tr><td class="paramname">version</td><td>Pointer to the variable where the product format version number will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
<div class="footer">
<hr><p>Copyright &copy; 2007-2021 <b>s<span class="soft-red">[</span>&amp;<span class="soft-red">]</span>t</b>, The Netherlands.
</p>
</div>
</div>
</body>
</html>
