<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>CODA Cursor</title>
<link href="../css/codadoc.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
</head>
<body>
<div class="wide">
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp;
<a class="qindex" href="modules.html">Modules</a> &nbsp;
</center>
<hr>
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">CODA Cursor</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga86506368d642120e9491eee25e45c2de"><td class="memItemLeft" align="right" valign="top">typedef struct coda_cursor_struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a></td></tr>
<tr class="separator:ga86506368d642120e9491eee25e45c2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab8f98f432a0be7844f8e9f2bf54d8173"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#gab8f98f432a0be7844f8e9f2bf54d8173">coda_cursor_read_int8</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, int8_t *dst)</td></tr>
<tr class="separator:gab8f98f432a0be7844f8e9f2bf54d8173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1093ca4fe1b54b1f41be2551c34a7c28"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga1093ca4fe1b54b1f41be2551c34a7c28">coda_cursor_read_uint8</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, uint8_t *dst)</td></tr>
<tr class="separator:ga1093ca4fe1b54b1f41be2551c34a7c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d5ceb277c7d281b790b371d67e0a082"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga9d5ceb277c7d281b790b371d67e0a082">coda_cursor_read_int16</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, int16_t *dst)</td></tr>
<tr class="separator:ga9d5ceb277c7d281b790b371d67e0a082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cc912a70964acd2c1d2570e9cf165e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga1cc912a70964acd2c1d2570e9cf165e4">coda_cursor_read_uint16</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, uint16_t *dst)</td></tr>
<tr class="separator:ga1cc912a70964acd2c1d2570e9cf165e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga273251b8b1c9ab5d6f2a23a9d5c150a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga273251b8b1c9ab5d6f2a23a9d5c150a1">coda_cursor_read_int32</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, int32_t *dst)</td></tr>
<tr class="separator:ga273251b8b1c9ab5d6f2a23a9d5c150a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1b61767aefb13134c099636dddce7c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#gaf1b61767aefb13134c099636dddce7c7">coda_cursor_read_uint32</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, uint32_t *dst)</td></tr>
<tr class="separator:gaf1b61767aefb13134c099636dddce7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabab325db9c84ad553adf6a5b6e65bca5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#gabab325db9c84ad553adf6a5b6e65bca5">coda_cursor_read_int64</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, int64_t *dst)</td></tr>
<tr class="separator:gabab325db9c84ad553adf6a5b6e65bca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga940188ac43bc49d7ab829c64b5d94645"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga940188ac43bc49d7ab829c64b5d94645">coda_cursor_read_uint64</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, uint64_t *dst)</td></tr>
<tr class="separator:ga940188ac43bc49d7ab829c64b5d94645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b9f163bcdca6ee0ae02c3c16f1aa15c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga4b9f163bcdca6ee0ae02c3c16f1aa15c">coda_cursor_read_float</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, float *dst)</td></tr>
<tr class="separator:ga4b9f163bcdca6ee0ae02c3c16f1aa15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4aa54ab5f18c8827435c834dc0415f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#gab4aa54ab5f18c8827435c834dc0415f9">coda_cursor_read_double</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, double *dst)</td></tr>
<tr class="separator:gab4aa54ab5f18c8827435c834dc0415f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7416cf18a02b88bff5d978d1eefbbd31"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga7416cf18a02b88bff5d978d1eefbbd31">coda_cursor_read_char</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, char *dst)</td></tr>
<tr class="separator:ga7416cf18a02b88bff5d978d1eefbbd31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga192bf0ab48a969fffd50e1d9b611d9b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga192bf0ab48a969fffd50e1d9b611d9b0">coda_cursor_read_string</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, char *dst, long dst_size)</td></tr>
<tr class="separator:ga192bf0ab48a969fffd50e1d9b611d9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a3671533d5d82a66e3d8ced808d7c07"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga2a3671533d5d82a66e3d8ced808d7c07">coda_cursor_read_bits</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, uint8_t *dst, int64_t bit_offset, int64_t bit_length)</td></tr>
<tr class="separator:ga2a3671533d5d82a66e3d8ced808d7c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa38cba1ab7f02e48d9f27e1117368ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#gaaa38cba1ab7f02e48d9f27e1117368ee">coda_cursor_read_bytes</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, uint8_t *dst, int64_t offset, int64_t length)</td></tr>
<tr class="separator:gaaa38cba1ab7f02e48d9f27e1117368ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b2e3f9f049e53f665326c177f781844"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga8b2e3f9f049e53f665326c177f781844">coda_cursor_read_int8_array</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, int8_t *dst, <a class="el" href="group__coda__general.html#ga43bbecf10194ddde79f34f1111b7597c">coda_array_ordering</a> array_ordering)</td></tr>
<tr class="separator:ga8b2e3f9f049e53f665326c177f781844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85867f3f87e0ab98de72b1e79360d488"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga85867f3f87e0ab98de72b1e79360d488">coda_cursor_read_uint8_array</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, uint8_t *dst, <a class="el" href="group__coda__general.html#ga43bbecf10194ddde79f34f1111b7597c">coda_array_ordering</a> array_ordering)</td></tr>
<tr class="separator:ga85867f3f87e0ab98de72b1e79360d488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae57bdba87431cddbcb9e5b9c114afad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#gaae57bdba87431cddbcb9e5b9c114afad">coda_cursor_read_int16_array</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, int16_t *dst, <a class="el" href="group__coda__general.html#ga43bbecf10194ddde79f34f1111b7597c">coda_array_ordering</a> array_ordering)</td></tr>
<tr class="separator:gaae57bdba87431cddbcb9e5b9c114afad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaec918e87885b76c1654291f383b0b3c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#gaaec918e87885b76c1654291f383b0b3c">coda_cursor_read_uint16_array</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, uint16_t *dst, <a class="el" href="group__coda__general.html#ga43bbecf10194ddde79f34f1111b7597c">coda_array_ordering</a> array_ordering)</td></tr>
<tr class="separator:gaaec918e87885b76c1654291f383b0b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga216a586c7e1dbc9c66673635a1a279cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga216a586c7e1dbc9c66673635a1a279cb">coda_cursor_read_int32_array</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, int32_t *dst, <a class="el" href="group__coda__general.html#ga43bbecf10194ddde79f34f1111b7597c">coda_array_ordering</a> array_ordering)</td></tr>
<tr class="separator:ga216a586c7e1dbc9c66673635a1a279cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6adacbfd82d0af87d53bfcbc2cbb72da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga6adacbfd82d0af87d53bfcbc2cbb72da">coda_cursor_read_uint32_array</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, uint32_t *dst, <a class="el" href="group__coda__general.html#ga43bbecf10194ddde79f34f1111b7597c">coda_array_ordering</a> array_ordering)</td></tr>
<tr class="separator:ga6adacbfd82d0af87d53bfcbc2cbb72da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga685b5a2e3bec4bee7bf48bc99971fbb2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga685b5a2e3bec4bee7bf48bc99971fbb2">coda_cursor_read_int64_array</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, int64_t *dst, <a class="el" href="group__coda__general.html#ga43bbecf10194ddde79f34f1111b7597c">coda_array_ordering</a> array_ordering)</td></tr>
<tr class="separator:ga685b5a2e3bec4bee7bf48bc99971fbb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06bfb416cddde9f8e8f67dc827a95b5e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga06bfb416cddde9f8e8f67dc827a95b5e">coda_cursor_read_uint64_array</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, uint64_t *dst, <a class="el" href="group__coda__general.html#ga43bbecf10194ddde79f34f1111b7597c">coda_array_ordering</a> array_ordering)</td></tr>
<tr class="separator:ga06bfb416cddde9f8e8f67dc827a95b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7563628d9041a15bd28e0f738af29c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#gaa7563628d9041a15bd28e0f738af29c3">coda_cursor_read_float_array</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, float *dst, <a class="el" href="group__coda__general.html#ga43bbecf10194ddde79f34f1111b7597c">coda_array_ordering</a> array_ordering)</td></tr>
<tr class="separator:gaa7563628d9041a15bd28e0f738af29c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98a4ed2ffa4dd5d063604ebdfc1b9c6b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga98a4ed2ffa4dd5d063604ebdfc1b9c6b">coda_cursor_read_double_array</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, double *dst, <a class="el" href="group__coda__general.html#ga43bbecf10194ddde79f34f1111b7597c">coda_array_ordering</a> array_ordering)</td></tr>
<tr class="separator:ga98a4ed2ffa4dd5d063604ebdfc1b9c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6ea0599122ae7b2249a4240f82d0a2c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#gae6ea0599122ae7b2249a4240f82d0a2c">coda_cursor_read_char_array</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, char *dst, <a class="el" href="group__coda__general.html#ga43bbecf10194ddde79f34f1111b7597c">coda_array_ordering</a> array_ordering)</td></tr>
<tr class="separator:gae6ea0599122ae7b2249a4240f82d0a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f223be340986a3bcf66d51622e65745"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga9f223be340986a3bcf66d51622e65745">coda_cursor_read_int8_partial_array</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, long offset, long length, int8_t *dst)</td></tr>
<tr class="separator:ga9f223be340986a3bcf66d51622e65745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a3879eb7d0a4312012a24e647f23afc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga0a3879eb7d0a4312012a24e647f23afc">coda_cursor_read_uint8_partial_array</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, long offset, long length, uint8_t *dst)</td></tr>
<tr class="separator:ga0a3879eb7d0a4312012a24e647f23afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e78a84fb20d59336055d402f2b7b830"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga7e78a84fb20d59336055d402f2b7b830">coda_cursor_read_int16_partial_array</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, long offset, long length, int16_t *dst)</td></tr>
<tr class="separator:ga7e78a84fb20d59336055d402f2b7b830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16d83093a7b5d52e4665785b66af0d55"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga16d83093a7b5d52e4665785b66af0d55">coda_cursor_read_uint16_partial_array</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, long offset, long length, uint16_t *dst)</td></tr>
<tr class="separator:ga16d83093a7b5d52e4665785b66af0d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c684d94f67f3e8bc6126be989f6cf04"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga5c684d94f67f3e8bc6126be989f6cf04">coda_cursor_read_int32_partial_array</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, long offset, long length, int32_t *dst)</td></tr>
<tr class="separator:ga5c684d94f67f3e8bc6126be989f6cf04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d71e54334a42567e7d0680cbd195df0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga3d71e54334a42567e7d0680cbd195df0">coda_cursor_read_uint32_partial_array</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, long offset, long length, uint32_t *dst)</td></tr>
<tr class="separator:ga3d71e54334a42567e7d0680cbd195df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6abbc189207419e23de2c26eea21cebc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga6abbc189207419e23de2c26eea21cebc">coda_cursor_read_int64_partial_array</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, long offset, long length, int64_t *dst)</td></tr>
<tr class="separator:ga6abbc189207419e23de2c26eea21cebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dd7a32908ea87ef0740e7c057f76b85"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga1dd7a32908ea87ef0740e7c057f76b85">coda_cursor_read_uint64_partial_array</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, long offset, long length, uint64_t *dst)</td></tr>
<tr class="separator:ga1dd7a32908ea87ef0740e7c057f76b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac276c2ea6e31974ea6b809cc0fbf3953"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#gac276c2ea6e31974ea6b809cc0fbf3953">coda_cursor_read_float_partial_array</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, long offset, long length, float *dst)</td></tr>
<tr class="separator:gac276c2ea6e31974ea6b809cc0fbf3953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb02ac86d877f6cd2e88416e64347a31"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#gadb02ac86d877f6cd2e88416e64347a31">coda_cursor_read_double_partial_array</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, long offset, long length, double *dst)</td></tr>
<tr class="separator:gadb02ac86d877f6cd2e88416e64347a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8572c07adc0d9b11b4da580cd7fcd548"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga8572c07adc0d9b11b4da580cd7fcd548">coda_cursor_read_char_partial_array</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, long offset, long length, char *dst)</td></tr>
<tr class="separator:ga8572c07adc0d9b11b4da580cd7fcd548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga079c36f25a4d4dcc87844e7fde47fefc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga079c36f25a4d4dcc87844e7fde47fefc">coda_cursor_read_complex_double_pair</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, double *dst)</td></tr>
<tr class="separator:ga079c36f25a4d4dcc87844e7fde47fefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0fd573997d9526199034333905d8012"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#gac0fd573997d9526199034333905d8012">coda_cursor_read_complex_double_pairs_array</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, double *dst, <a class="el" href="group__coda__general.html#ga43bbecf10194ddde79f34f1111b7597c">coda_array_ordering</a> array_ordering)</td></tr>
<tr class="separator:gac0fd573997d9526199034333905d8012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga011d3964e1768f34c7decbce68af5b51"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga011d3964e1768f34c7decbce68af5b51">coda_cursor_read_complex_double_split</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, double *dst_re, double *dst_im)</td></tr>
<tr class="separator:ga011d3964e1768f34c7decbce68af5b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga496a8360cb05ddc771a4ec54b4f711f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga496a8360cb05ddc771a4ec54b4f711f8">coda_cursor_read_complex_double_split_array</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, double *dst_re, double *dst_im, <a class="el" href="group__coda__general.html#ga43bbecf10194ddde79f34f1111b7597c">coda_array_ordering</a> array_ordering)</td></tr>
<tr class="separator:ga496a8360cb05ddc771a4ec54b4f711f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cc6cb89a9b6ce8643cc59dae36d665c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga6cc6cb89a9b6ce8643cc59dae36d665c">coda_cursor_print_path</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, int(*print)(const char *,...))</td></tr>
<tr class="separator:ga6cc6cb89a9b6ce8643cc59dae36d665c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c6a6c2bac64e9ab3f9b71d178a3e04d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga7c6a6c2bac64e9ab3f9b71d178a3e04d">coda_cursor_set_product</a> (<a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, <a class="el" href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a> *product)</td></tr>
<tr class="separator:ga7c6a6c2bac64e9ab3f9b71d178a3e04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad219a5443ad5d3ad1374a7c18e82c484"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#gad219a5443ad5d3ad1374a7c18e82c484">coda_cursor_goto</a> (<a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, const char *path)</td></tr>
<tr class="separator:gad219a5443ad5d3ad1374a7c18e82c484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc5a15560bc592b23118d05c44dd56fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#gadc5a15560bc592b23118d05c44dd56fa">coda_cursor_goto_first_record_field</a> (<a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor)</td></tr>
<tr class="separator:gadc5a15560bc592b23118d05c44dd56fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73627cc159418db44064525205b78b9a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga73627cc159418db44064525205b78b9a">coda_cursor_goto_record_field_by_index</a> (<a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, long index)</td></tr>
<tr class="separator:ga73627cc159418db44064525205b78b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaaa4f6eedb6d2463cffc64416de16fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#gaeaaa4f6eedb6d2463cffc64416de16fc">coda_cursor_goto_record_field_by_name</a> (<a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, const char *name)</td></tr>
<tr class="separator:gaeaaa4f6eedb6d2463cffc64416de16fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cfed551f3ad8406b7148f1019c19dc2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga9cfed551f3ad8406b7148f1019c19dc2">coda_cursor_goto_next_record_field</a> (<a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor)</td></tr>
<tr class="separator:ga9cfed551f3ad8406b7148f1019c19dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6a9c2d77774bf323f98267c8918a4ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#gab6a9c2d77774bf323f98267c8918a4ba">coda_cursor_goto_available_union_field</a> (<a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor)</td></tr>
<tr class="separator:gab6a9c2d77774bf323f98267c8918a4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90362bd9b257866af5373f43947925f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga90362bd9b257866af5373f43947925f4">coda_cursor_goto_first_array_element</a> (<a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor)</td></tr>
<tr class="separator:ga90362bd9b257866af5373f43947925f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe204ba1224c8767c7f6dce1cf548281"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#gabe204ba1224c8767c7f6dce1cf548281">coda_cursor_goto_array_element</a> (<a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, int num_subs, const long subs[])</td></tr>
<tr class="separator:gabe204ba1224c8767c7f6dce1cf548281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08300afc8797ef5bba44b2acb316bdaf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga08300afc8797ef5bba44b2acb316bdaf">coda_cursor_goto_array_element_by_index</a> (<a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, long index)</td></tr>
<tr class="separator:ga08300afc8797ef5bba44b2acb316bdaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0251269bb9774efc232cf6771ca9692"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#gaf0251269bb9774efc232cf6771ca9692">coda_cursor_goto_next_array_element</a> (<a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor)</td></tr>
<tr class="separator:gaf0251269bb9774efc232cf6771ca9692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf89949182ab2c80f2fd7705954780141"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#gaf89949182ab2c80f2fd7705954780141">coda_cursor_goto_attributes</a> (<a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor)</td></tr>
<tr class="separator:gaf89949182ab2c80f2fd7705954780141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbb9fba27af87d3b854194316a1f8c08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#gadbb9fba27af87d3b854194316a1f8c08">coda_cursor_goto_parent</a> (<a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor)</td></tr>
<tr class="separator:gadbb9fba27af87d3b854194316a1f8c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e6ef524e9b26dfa910919905685a078"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga1e6ef524e9b26dfa910919905685a078">coda_cursor_goto_root</a> (<a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor)</td></tr>
<tr class="separator:ga1e6ef524e9b26dfa910919905685a078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa58abc3d22330e5d322c9f8147a99d2e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#gaa58abc3d22330e5d322c9f8147a99d2e">coda_cursor_use_base_type_of_special_type</a> (<a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor)</td></tr>
<tr class="separator:gaa58abc3d22330e5d322c9f8147a99d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78778d16b62c5aa31737e3cd1f2b7f2c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga78778d16b62c5aa31737e3cd1f2b7f2c">coda_cursor_has_ascii_content</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, int *has_ascii_content)</td></tr>
<tr class="separator:ga78778d16b62c5aa31737e3cd1f2b7f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92e3c49aac0ab643fc1a618a5438debe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga92e3c49aac0ab643fc1a618a5438debe">coda_cursor_has_attributes</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, int *has_attributes)</td></tr>
<tr class="separator:ga92e3c49aac0ab643fc1a618a5438debe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58e9930a607eb175c31e37bfd36221ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga58e9930a607eb175c31e37bfd36221ec">coda_cursor_get_string_length</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, long *length)</td></tr>
<tr class="separator:ga58e9930a607eb175c31e37bfd36221ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89b00a15869a4d873a260f1f2a6a6a5a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga89b00a15869a4d873a260f1f2a6a6a5a">coda_cursor_get_bit_size</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, int64_t *bit_size)</td></tr>
<tr class="separator:ga89b00a15869a4d873a260f1f2a6a6a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga102d7cd1a4eba65aa6f5d0639cd07fd7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga102d7cd1a4eba65aa6f5d0639cd07fd7">coda_cursor_get_byte_size</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, int64_t *byte_size)</td></tr>
<tr class="separator:ga102d7cd1a4eba65aa6f5d0639cd07fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9e4cc79aea8d6f50f8406c2fddc66c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#gab9e4cc79aea8d6f50f8406c2fddc66c8">coda_cursor_get_num_elements</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, long *num_elements)</td></tr>
<tr class="separator:gab9e4cc79aea8d6f50f8406c2fddc66c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70cb9546df8abf6603130bbbe0dfe77c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga70cb9546df8abf6603130bbbe0dfe77c">coda_cursor_get_product_file</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, <a class="el" href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a> **product)</td></tr>
<tr class="separator:ga70cb9546df8abf6603130bbbe0dfe77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f8a1e0c971c5c7600a0080ae434c641"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga5f8a1e0c971c5c7600a0080ae434c641">coda_cursor_get_depth</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, int *depth)</td></tr>
<tr class="separator:ga5f8a1e0c971c5c7600a0080ae434c641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50788d35dac8d080fdc1cdc8665ab929"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga50788d35dac8d080fdc1cdc8665ab929">coda_cursor_get_index</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, long *index)</td></tr>
<tr class="separator:ga50788d35dac8d080fdc1cdc8665ab929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a1f1fa599b0c1dc133909c5927e691f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga2a1f1fa599b0c1dc133909c5927e691f">coda_cursor_get_file_bit_offset</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, int64_t *bit_offset)</td></tr>
<tr class="separator:ga2a1f1fa599b0c1dc133909c5927e691f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4ba329733e394f25e1d5d307b1d0550"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#gad4ba329733e394f25e1d5d307b1d0550">coda_cursor_get_file_byte_offset</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, int64_t *byte_offset)</td></tr>
<tr class="separator:gad4ba329733e394f25e1d5d307b1d0550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb8f1d68ea01dd1a88cc0705375a4176"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#gabb8f1d68ea01dd1a88cc0705375a4176">coda_cursor_get_format</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, <a class="el" href="group__coda__general.html#ga8e2552c6f87737610ef2bcce876e9e06">coda_format</a> *format)</td></tr>
<tr class="separator:gabb8f1d68ea01dd1a88cc0705375a4176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9385484d45d6d2111d22c463fca753b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga9385484d45d6d2111d22c463fca753b0">coda_cursor_get_type_class</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, <a class="el" href="group__coda__types.html#ga0b65543edf29d8698b8ec4ce26a06727">coda_type_class</a> *type_class)</td></tr>
<tr class="separator:ga9385484d45d6d2111d22c463fca753b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5782297b79e79e2e6ab4a8c0970c24a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga5782297b79e79e2e6ab4a8c0970c24a7">coda_cursor_get_read_type</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, <a class="el" href="group__coda__types.html#gaa9e9bf24f8f66326e8b4f7879255a360">coda_native_type</a> *read_type)</td></tr>
<tr class="separator:ga5782297b79e79e2e6ab4a8c0970c24a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10dc045955e767168d10af85560c0372"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga10dc045955e767168d10af85560c0372">coda_cursor_get_special_type</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, <a class="el" href="group__coda__types.html#ga3cc872a9bdae676638f86fbf5052ee7e">coda_special_type</a> *special_type)</td></tr>
<tr class="separator:ga10dc045955e767168d10af85560c0372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f9f142b7b7adc422587f08bd9c17e07"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga6f9f142b7b7adc422587f08bd9c17e07">coda_cursor_get_type</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, <a class="el" href="group__coda__types.html#ga1b591a7c6147d5785a0257a8b6fbc864">coda_type</a> **type)</td></tr>
<tr class="separator:ga6f9f142b7b7adc422587f08bd9c17e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89fb44362ee0585468c33eaeedb4a78d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga89fb44362ee0585468c33eaeedb4a78d">coda_cursor_get_record_field_index_from_name</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, const char *name, long *index)</td></tr>
<tr class="separator:ga89fb44362ee0585468c33eaeedb4a78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae98f5d50feff40682072978674ca11ae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#gae98f5d50feff40682072978674ca11ae">coda_cursor_get_record_field_available_status</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, long index, int *available)</td></tr>
<tr class="separator:gae98f5d50feff40682072978674ca11ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a8dfc1b1c6a6de2f7d4b8d2c1f34e5e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#ga6a8dfc1b1c6a6de2f7d4b8d2c1f34e5e">coda_cursor_get_available_union_field_index</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, long *index)</td></tr>
<tr class="separator:ga6a8dfc1b1c6a6de2f7d4b8d2c1f34e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac383bb48a0aef63af6c128e8af96238a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coda__cursor.html#gac383bb48a0aef63af6c128e8af96238a">coda_cursor_get_array_dim</a> (const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *cursor, int *num_dims, long dim[])</td></tr>
<tr class="separator:gac383bb48a0aef63af6c128e8af96238a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>After you have opened a product file with <a class="el" href="group__coda__product.html#ga6f6c7522db4933704d582c6b98e9d1aa">coda_open()</a> (see <a class="el" href="group__coda__product.html">CODA Product</a>) you will want to access data from this product and retrieve metadata for the data elements (see <a class="el" href="group__coda__types.html">CODA Types</a>). In order to do this, CODA provides the concept of a 'cursor'. A cursor can be thought of as something that keeps track of a position in the product file and it also stores some extra (type) information about the data element it is currently pointing to. Cursors will start their useful life at the 'root' of a product, i.e., pointing to the entire product, with a type that accurately describes the entire product. From there you can navigate the cursor to the specific data element(s) you want to access. Note that cursors are used for all products that can be opened with CODA. This includes files in ascii, binary, XML, netCDF, HDF4, or HDF5 format.</p>
<p>You can initialize a cursor to point to the product root via the following function:</p>
<ul>
<li><a class="el" href="group__coda__cursor.html#ga7c6a6c2bac64e9ab3f9b71d178a3e04d">coda_cursor_set_product()</a></li>
</ul>
<p>Suppose that we want to read the absolute orbit number value from the MPH of an ESA ENVISAT product file. In order to do this, we first have to use the <a class="el" href="group__coda__cursor.html#ga7c6a6c2bac64e9ab3f9b71d178a3e04d">coda_cursor_set_product()</a> function to initialize a cursor to point to the complete product. As explained in the CODA Types section (see <a class="el" href="group__coda__types.html">CODA Types</a>) all data elements of a product file can be categorized in arrays, records, and basic types (int16, double, complex float, etc.). The product root of an ENVISAT file is a record, which means that we are able to call the <a class="el" href="group__coda__cursor.html#gaeaaa4f6eedb6d2463cffc64416de16fc">coda_cursor_goto_record_field_by_name()</a> to navigate to the MPH. The MPH to which the cursor is then pointing is again a record, so we can call the <a class="el" href="group__coda__cursor.html#gaeaaa4f6eedb6d2463cffc64416de16fc">coda_cursor_goto_record_field_by_name()</a> function again to move the cursor to a certain MPH field. We are interested in the absolute orbit, so if we call this function with the fieldname "abs_orbit". Our cursor will now point to the location in the product file that contains the value we want.</p>
<p>Once we have moved the cursor to the right location we have to read the data that it is pointing to. In order to do that, we first want to find out the best native type to read the absolute orbit value. You can either determine this by looking it up in the CODA Product Format Definition documentation for the product or you can use the <a class="el" href="group__coda__cursor.html#ga5782297b79e79e2e6ab4a8c0970c24a7">coda_cursor_get_read_type()</a> on the cursor. Both methods will show you that the absolute orbit is stored as a <code>int32</code> value.</p>
<p>Since the value is a signed 32-bit integer, we will call <a class="el" href="group__coda__cursor.html#ga273251b8b1c9ab5d6f2a23a9d5c150a1">coda_cursor_read_int32()</a> to read the absolute orbit value (Notice that this function returns the value as an int32_t type. CODA use these bit-specific types because not every platform that CODA runs on uses the same amount of bits for the C types short, int, and long). It is however also possible to read the 32-bit integer using a CODA read function that returns a native type that is <em>larger</em> than an int32. For instance, you can also read the 32-bit integer value using <a class="el" href="group__coda__cursor.html#gabab325db9c84ad553adf6a5b6e65bca5">coda_cursor_read_int64()</a> or <a class="el" href="group__coda__cursor.html#gab4aa54ab5f18c8827435c834dc0415f9">coda_cursor_read_double()</a>, which would return the value as an int64_t or double value (you can't however read the signed 32 bit integer using an unsigned integer type (e.g. uint32) or using a shorter type (e.g. int16)).</p>
<p>A small example that performs all these steps and prints the retrieved orbit number is given below. Note that, for the sake of clarity, we omit error checking: </p><div class="fragment"><div class="line"><a class="code" href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a> *product;</div>
<div class="line"><a class="code" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> cursor;</div>
<div class="line">int32_t abs_orbit_val;</div>
<div class="line"><a class="code" href="group__coda__general.html#ga8e7601eb0f115a4052e4af96668b3429">coda_init</a>();</div>
<div class="line">product = <a class="code" href="group__coda__product.html#ga6f6c7522db4933704d582c6b98e9d1aa">coda_open</a>(<span class="stringliteral">&quot;... path to envisat product file ...&quot;</span>);</div>
<div class="line"><a class="code" href="group__coda__cursor.html#ga7c6a6c2bac64e9ab3f9b71d178a3e04d">coda_cursor_set_product</a>(&amp;cursor, product);</div>
<div class="line"><a class="code" href="group__coda__cursor.html#gaeaaa4f6eedb6d2463cffc64416de16fc">coda_cursor_goto_record_field_by_name</a>(&amp;cursor, <span class="stringliteral">&quot;mph&quot;</span>);</div>
<div class="line"><a class="code" href="group__coda__cursor.html#gaeaaa4f6eedb6d2463cffc64416de16fc">coda_cursor_goto_record_field_by_name</a>(&amp;cursor, <span class="stringliteral">&quot;abs_orbit&quot;</span>);</div>
<div class="line"><a class="code" href="group__coda__cursor.html#ga273251b8b1c9ab5d6f2a23a9d5c150a1">coda_cursor_read_int32</a>(&amp;cursor, &amp;abs_orbit_val);</div>
<div class="line">printf(<span class="stringliteral">&quot;absolute orbit: %ld\n&quot;</span>, (<span class="keywordtype">long</span>)abs_orbit_val);</div>
<div class="line"><a class="code" href="group__coda__product.html#gad81f6fd1300679fe3715d78953d96cc8">coda_close</a>(product);</div>
<div class="line"><a class="code" href="group__coda__general.html#gaf238ffee3073c81b6e80fb03d9968386">coda_done</a>();</div>
<div class="ttc" id="agroup__coda__cursor_html_ga273251b8b1c9ab5d6f2a23a9d5c150a1"><div class="ttname"><a href="group__coda__cursor.html#ga273251b8b1c9ab5d6f2a23a9d5c150a1">coda_cursor_read_int32</a></div><div class="ttdeci">int coda_cursor_read_int32(const coda_cursor *cursor, int32_t *dst)</div><div class="ttdef"><b>Definition:</b> coda-cursor-read.c:1995</div></div>
<div class="ttc" id="agroup__coda__cursor_html_ga7c6a6c2bac64e9ab3f9b71d178a3e04d"><div class="ttname"><a href="group__coda__cursor.html#ga7c6a6c2bac64e9ab3f9b71d178a3e04d">coda_cursor_set_product</a></div><div class="ttdeci">int coda_cursor_set_product(coda_cursor *cursor, coda_product *product)</div><div class="ttdef"><b>Definition:</b> coda-cursor.c:316</div></div>
<div class="ttc" id="agroup__coda__cursor_html_ga86506368d642120e9491eee25e45c2de"><div class="ttname"><a href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a></div><div class="ttdeci">struct coda_cursor_struct coda_cursor</div><div class="ttdef"><b>Definition:</b> coda.h:326</div></div>
<div class="ttc" id="agroup__coda__cursor_html_gaeaaa4f6eedb6d2463cffc64416de16fc"><div class="ttname"><a href="group__coda__cursor.html#gaeaaa4f6eedb6d2463cffc64416de16fc">coda_cursor_goto_record_field_by_name</a></div><div class="ttdeci">int coda_cursor_goto_record_field_by_name(coda_cursor *cursor, const char *name)</div><div class="ttdef"><b>Definition:</b> coda-cursor.c:656</div></div>
<div class="ttc" id="agroup__coda__general_html_ga8e7601eb0f115a4052e4af96668b3429"><div class="ttname"><a href="group__coda__general.html#ga8e7601eb0f115a4052e4af96668b3429">coda_init</a></div><div class="ttdeci">int coda_init(void)</div><div class="ttdef"><b>Definition:</b> coda.c:484</div></div>
<div class="ttc" id="agroup__coda__general_html_gaf238ffee3073c81b6e80fb03d9968386"><div class="ttname"><a href="group__coda__general.html#gaf238ffee3073c81b6e80fb03d9968386">coda_done</a></div><div class="ttdeci">void coda_done(void)</div><div class="ttdef"><b>Definition:</b> coda.c:555</div></div>
<div class="ttc" id="agroup__coda__product_html_ga6f6c7522db4933704d582c6b98e9d1aa"><div class="ttname"><a href="group__coda__product.html#ga6f6c7522db4933704d582c6b98e9d1aa">coda_open</a></div><div class="ttdeci">int coda_open(const char *filename, coda_product **product)</div><div class="ttdef"><b>Definition:</b> coda-product.c:658</div></div>
<div class="ttc" id="agroup__coda__product_html_gaaf31b4b329a9b03d6e7e7a386c466cf6"><div class="ttname"><a href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a></div><div class="ttdeci">struct coda_product_struct coda_product</div><div class="ttdef"><b>Definition:</b> coda.h:325</div></div>
<div class="ttc" id="agroup__coda__product_html_gad81f6fd1300679fe3715d78953d96cc8"><div class="ttname"><a href="group__coda__product.html#gad81f6fd1300679fe3715d78953d96cc8">coda_close</a></div><div class="ttdeci">int coda_close(coda_product *product)</div><div class="ttdef"><b>Definition:</b> coda-product.c:770</div></div>
</div><!-- fragment --><p>After you have moved a cursor to a specific data element, it is possible to reuse the cursor and move it to other data elements. Suppose that, after reading the absolute orbit, we now want to read the relative orbit. In order to do that we first we have to go back to the MPH record. To have the cursor move to its encapsulating record or array you can use the <a class="el" href="group__coda__cursor.html#gadbb9fba27af87d3b854194316a1f8c08">coda_cursor_goto_parent()</a> function. After that, we can call <a class="el" href="group__coda__cursor.html#gaeaaa4f6eedb6d2463cffc64416de16fc">coda_cursor_goto_record_field_by_name()</a> again but now with the string "rel_orbit" as fieldname parameter.</p>
<p>An important aspect of using cursors is that you do not have to clean up a cursor. Memory can be reserved for a cursor simply by declaring it; the initialization of the cursor with a <a class="el" href="group__coda__cursor.html#ga7c6a6c2bac64e9ab3f9b71d178a3e04d">coda_cursor_set_product()</a> function does not require any memory allocation. Another advantage of this kind of implementation is that you can easily make a copy of a cursor. Suppose we have a cursor <code>record_cursor</code> that points to a record and we want to have an extra cursor <code>field_cursor</code> that points to the 'dsr_time' field of this record. This can be done as follows: </p><div class="fragment"><div class="line"><a class="code" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> field_cursor;</div>
<div class="line">field_cursor = record_cursor;</div>
<div class="line"><a class="code" href="group__coda__cursor.html#gaeaaa4f6eedb6d2463cffc64416de16fc">coda_cursor_goto_record_field_by_name</a>(&amp;field_cursor, <span class="stringliteral">&quot;dsr_time&quot;</span>);</div>
</div><!-- fragment --><p>First we copy the record cursor's contents into the field cursor through a simple assignment. The <code>field_cursor</code> now also points to the full record. Then we move <code>field_cursor</code> to the dsr_time field (after this, <code>record_cursor</code> still points to the whole record). </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga86506368d642120e9491eee25e45c2de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86506368d642120e9491eee25e45c2de">&#9670;&nbsp;</a></span>coda_cursor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CODA Cursor </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gac383bb48a0aef63af6c128e8af96238a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac383bb48a0aef63af6c128e8af96238a">&#9670;&nbsp;</a></span>coda_cursor_get_array_dim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_get_array_dim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>num_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>dim</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the dimensions of the data array that the cursor points to. The function returns both the number of dimensions <em>num_dims</em> and the size of the dimensions <em>dim</em>. </p><dl class="section note"><dt>Note</dt><dd>If the size of the dimensions is variable (it differs per product or differs per data element inside one product) then this function will calculate the dimensions from the necessary properties inside the product. Depending on the complexity of this calculation the determination of variable sized dimensions could impact performance. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">num_dims</td><td>Pointer to the variable where the number of dimensions will be stored. </td></tr>
    <tr><td class="paramname">dim</td><td>Pointer to the variable where the dimensions will be stored. The caller needs to make sure that the variable has enough room to store the dimensions array. It is guaranteed that the number of dimensions will never exceed <a class="el" href="group__coda__general.html#ga23cf6b5f0dccbf849cf656acd3f5b211">CODA_MAX_NUM_DIMS</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga6a8dfc1b1c6a6de2f7d4b8d2c1f34e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a8dfc1b1c6a6de2f7d4b8d2c1f34e5e">&#9670;&nbsp;</a></span>coda_cursor_get_available_union_field_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_get_available_union_field_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines which union record field is available in the product. </p><dl class="section note"><dt>Note</dt><dd>It is allowed to move a cursor to an unavailable union record field. In that case the data type for the field will be set to the special <a class="el" href="group__coda__types.html#ggab0124a9650f42b5f4eb2eb21535539ebae9150e17f22a06e36de3dc1037047d00">coda_special_no_data</a> data type (with type class <a class="el" href="group__coda__types.html#ggaa4d9bef64d23de166a5e0249504f5afaa5d605b83d52f350f6525d9ee8576f34f">coda_special_class</a>), which has a bit/byte length of 0. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">index</td><td>Pointer to the variable where the index of the available record field will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga89b00a15869a4d873a260f1f2a6a6a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89b00a15869a4d873a260f1f2a6a6a5a">&#9670;&nbsp;</a></span>coda_cursor_get_bit_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_get_bit_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>bit_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the bit size for the data at the current cursor position. Depending on the type of data and its format this function will return the following: For data in ascii or binary format all data types will return the amount of bits the data occupies in the product file. This means that e.g. ascii floats and ascii integers will return 8 times the byte size of the ascii representation, records and arrays return the sum of the bit sizes of their fields/array-elements. For XML data you will be able to retrieve bit sizes for all data except arrays and attribute records. You will not be able to retrieve bit/byte sizes for data in netCDF, HDF4 or HDF5 format. If a bit size is not available <em>bit_size</em> will be set to -1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a valid CODA cursor. </td></tr>
    <tr><td class="paramname">bit_size</td><td>Pointer to the variable where the bit size will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga102d7cd1a4eba65aa6f5d0639cd07fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga102d7cd1a4eba65aa6f5d0639cd07fd7">&#9670;&nbsp;</a></span>coda_cursor_get_byte_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_get_byte_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>byte_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the byte size for the data at the current cursor position. This function will retrieve the bit_size using <a class="el" href="group__coda__cursor.html#ga89b00a15869a4d873a260f1f2a6a6a5a">coda_cursor_get_bit_size()</a>, convert it to a byte size by rounding it up to the nearest byte, and return this byte size. If the bit size is -1, then this function will also return -1 for <em>byte_size</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a valid CODA cursor. </td></tr>
    <tr><td class="paramname">byte_size</td><td>Pointer to the variable where the byte size will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga5f8a1e0c971c5c7600a0080ae434c641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f8a1e0c971c5c7600a0080ae434c641">&#9670;&nbsp;</a></span>coda_cursor_get_depth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_get_depth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the current hierarchical depth of the cursor. The depth indicates how deep one has traversed into a product file and equals the amount of calls to <a class="el" href="group__coda__cursor.html#gadbb9fba27af87d3b854194316a1f8c08">coda_cursor_goto_parent()</a> one has to call to end up at the root of the product. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">depth</td><td>Pointer to the variable where the cursor depth will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga2a1f1fa599b0c1dc133909c5927e691f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a1f1fa599b0c1dc133909c5927e691f">&#9670;&nbsp;</a></span>coda_cursor_get_file_bit_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_get_file_bit_offset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>bit_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the file offset in bits of the data element that the cursor points to. You will not be able to retrieve bit/byte offsets for data in netCDF, HDF4, or HDF5 format. For data in XML format you will not be able to retrieve bit/byte offsets for arrays or attribute records. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">bit_offset</td><td>Pointer to the variable where the file offset in bits will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gad4ba329733e394f25e1d5d307b1d0550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4ba329733e394f25e1d5d307b1d0550">&#9670;&nbsp;</a></span>coda_cursor_get_file_byte_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_get_file_byte_offset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>byte_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the file offset in bytes of the data element that the cursor points to. The byte offset is determined by the bit offset of the data element. If the current bit offset does not end at a byte boundary the returned byte offest will be determined by rounding the bit offset down to the nearest byte. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>Pointer to the variable where the (possibly rounded) file offset in bytes will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gabb8f1d68ea01dd1a88cc0705375a4176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb8f1d68ea01dd1a88cc0705375a4176">&#9670;&nbsp;</a></span>coda_cursor_get_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_get_format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__coda__general.html#ga8e2552c6f87737610ef2bcce876e9e06">coda_format</a> *&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the storage format of the data element that the cursor points to. This has the same result as calling <a class="el" href="group__coda__types.html#gadd578623f4a02d0132abe2ff81bab1bd">coda_type_get_format()</a> with the result from <a class="el" href="group__coda__cursor.html#ga6f9f142b7b7adc422587f08bd9c17e07">coda_cursor_get_type()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">format</td><td>Pointer to the variable where the format will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga50788d35dac8d080fdc1cdc8665ab929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50788d35dac8d080fdc1cdc8665ab929">&#9670;&nbsp;</a></span>coda_cursor_get_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_get_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the array element or field index of the data element that the cursor points to. If the parent of the cursor points to a record then this function will return the field index of the current data element. In case the parent points to an array then the array element index (the same kind of index that is used for <a class="el" href="group__coda__cursor.html#ga08300afc8797ef5bba44b2acb316bdaf">coda_cursor_goto_array_element_by_index()</a>) will be returned. If the cursor has no parent or if the cursor points to an attribute record then this function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">index</td><td>Pointer to the variable where the index will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gab9e4cc79aea8d6f50f8406c2fddc66c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9e4cc79aea8d6f50f8406c2fddc66c8">&#9670;&nbsp;</a></span>coda_cursor_get_num_elements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_get_num_elements </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>num_elements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the number of elements of the data that is pointed to by the cursor. If the cursor points to an array the function will return the total number of elements of the array. If the cursor references a record then the number of fields of the record will be returned. For all other types the function will return 1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a valid CODA cursor. </td></tr>
    <tr><td class="paramname">num_elements</td><td>Pointer to the variable where the number of elements will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>&gt;=0</code>, Number of elements of the data in the product. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga70cb9546df8abf6603130bbbe0dfe77c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70cb9546df8abf6603130bbbe0dfe77c">&#9670;&nbsp;</a></span>coda_cursor_get_product_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_get_product_file </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a> **&#160;</td>
          <td class="paramname"><em>product</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the Product handle that was used to initialize this cursor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">product</td><td>Pointer to a product file handle pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga5782297b79e79e2e6ab4a8c0970c24a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5782297b79e79e2e6ab4a8c0970c24a7">&#9670;&nbsp;</a></span>coda_cursor_get_read_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_get_read_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__coda__types.html#gaa9e9bf24f8f66326e8b4f7879255a360">coda_native_type</a> *&#160;</td>
          <td class="paramname"><em>read_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the best native type for reading data at the current cursor position. This has the same result as calling <a class="el" href="group__coda__types.html#gae851e4b1832b37f4fe8f25e4a7485ebe">coda_type_get_read_type()</a> with the result from <a class="el" href="group__coda__cursor.html#ga6f9f142b7b7adc422587f08bd9c17e07">coda_cursor_get_type()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__coda__types.html#gae851e4b1832b37f4fe8f25e4a7485ebe">coda_type_get_read_type()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">read_type</td><td>Pointer to the variable where the read type will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gae98f5d50feff40682072978674ca11ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae98f5d50feff40682072978674ca11ae">&#9670;&nbsp;</a></span>coda_cursor_get_record_field_available_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_get_record_field_available_status </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>available</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines whether a record field is available in the product. This function allows you to check whether a dynamically available field in a record is available or not. If the field is available then <em>available</em> will be 1, otherwise it will be 0. </p><dl class="section note"><dt>Note</dt><dd>If a record is a union then only one field in the record will be available. </dd>
<dd>
It is allowed to move a CODA cursor to an unavailable field. In that case the data type for the field will be set to the special <a class="el" href="group__coda__types.html#ggab0124a9650f42b5f4eb2eb21535539ebae9150e17f22a06e36de3dc1037047d00">coda_special_no_data</a> data type (with type class <a class="el" href="group__coda__types.html#ggaa4d9bef64d23de166a5e0249504f5afaa5d605b83d52f350f6525d9ee8576f34f">coda_special_class</a>), which has a bit/byte size of 0. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">index</td><td>Index of the field (0 &lt;= <em>index</em> &lt; number of fields). </td></tr>
    <tr><td class="paramname">available</td><td>Pointer to the variable where the available status will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga89fb44362ee0585468c33eaeedb4a78d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89fb44362ee0585468c33eaeedb4a78d">&#9670;&nbsp;</a></span>coda_cursor_get_record_field_index_from_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_get_record_field_index_from_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the field index from a field name for the record at the current cursor position. If the cursor does not point to a record the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the record field. </td></tr>
    <tr><td class="paramname">index</td><td>Pointer to a variable where the field index will be stored (0 &lt;= <em>index</em> &lt; number of fields). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga10dc045955e767168d10af85560c0372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10dc045955e767168d10af85560c0372">&#9670;&nbsp;</a></span>coda_cursor_get_special_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_get_special_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__coda__types.html#ga3cc872a9bdae676638f86fbf5052ee7e">coda_special_type</a> *&#160;</td>
          <td class="paramname"><em>special_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the special type of the data element that the cursor points to. This has the same result as calling <a class="el" href="group__coda__types.html#gad1fb786cae51605b82ed6f93bd69172e">coda_type_get_special_type()</a> with the result from <a class="el" href="group__coda__cursor.html#ga6f9f142b7b7adc422587f08bd9c17e07">coda_cursor_get_type()</a>. The class of the data type that the cursor points to should be <a class="el" href="group__coda__types.html#ggaa4d9bef64d23de166a5e0249504f5afaa5d605b83d52f350f6525d9ee8576f34f">coda_special_class</a>, otherwise this function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">special_type</td><td>Pointer to the variable where the special type will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga58e9930a607eb175c31e37bfd36221ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58e9930a607eb175c31e37bfd36221ec">&#9670;&nbsp;</a></span>coda_cursor_get_string_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_get_string_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the length in bytes of a string data type. The length that is returned does not include the additional byte needed for the terminating 0. This means that if you want to call <a class="el" href="group__coda__cursor.html#ga192bf0ab48a969fffd50e1d9b611d9b0">coda_cursor_read_string()</a> you should allocate <em>length</em> + 1 amount of bytes and pass a value of <em>length</em> + 1 for the dst_size parameter of <a class="el" href="group__coda__cursor.html#ga192bf0ab48a969fffd50e1d9b611d9b0">coda_cursor_read_string()</a>. If the cursor does not point to string data the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a valid CODA cursor. </td></tr>
    <tr><td class="paramname">length</td><td>Pointer to the variable where the string length will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga6f9f142b7b7adc422587f08bd9c17e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f9f142b7b7adc422587f08bd9c17e07">&#9670;&nbsp;</a></span>coda_cursor_get_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_get_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__coda__types.html#ga1b591a7c6147d5785a0257a8b6fbc864">coda_type</a> **&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the CODA type of the data element that the cursor points to. Refer to the section about <a class="el" href="group__coda__types.html">CODA Types </a> to find more information on how to use the CODA type to get more information about a data element. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">type</td><td>Pointer to the variable where the type will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga9385484d45d6d2111d22c463fca753b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9385484d45d6d2111d22c463fca753b0">&#9670;&nbsp;</a></span>coda_cursor_get_type_class()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_get_type_class </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__coda__types.html#ga0b65543edf29d8698b8ec4ce26a06727">coda_type_class</a> *&#160;</td>
          <td class="paramname"><em>type_class</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the type class of the data element that the cursor points to. This has the same result as calling <a class="el" href="group__coda__types.html#ga6b352b8859784c0d8a542dedbea13b66">coda_type_get_class()</a> with the result from <a class="el" href="group__coda__cursor.html#ga6f9f142b7b7adc422587f08bd9c17e07">coda_cursor_get_type()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">type_class</td><td>Pointer to the variable where the type class will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gad219a5443ad5d3ad1374a7c18e82c484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad219a5443ad5d3ad1374a7c18e82c484">&#9670;&nbsp;</a></span>coda_cursor_goto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_goto </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the cursor to the location in the product as specified by a path string. The <em>path</em> string should contain a path reference similar to a 'node expression' (see <a class="el" href="group__coda__expression.html">CODA expression language</a>). The <em>cursor</em> parameter should contain a properly initialised cursor (e.g. using <a class="el" href="group__coda__cursor.html#ga7c6a6c2bac64e9ab3f9b71d178a3e04d">coda_cursor_set_product()</a>) The cursor position of <em>cursor</em> will be updated based on the path provided. This can be a move relative to the current cursor position in case of a relative path specification or an explicit move in case of an absolute path specification (i.e. if the node expression starts with '/'). Although the <em>path</em> parameter is similar to a CODA node expression, there are a few differences:</p><ul>
<li>the ':' specifier is not allowed (use '.')</li>
<li>a relative path that starts with a field reference does not have to start with a './', you can immediately start with the field name (e.g. you can use 'foo/bar' instead of './foo/bar') <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a valid CODA cursor. </td></tr>
    <tr><td class="paramname">path</td><td>A string representing a path to a location inside a product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>
</li>
</ul>

</div>
</div>
<a id="gabe204ba1224c8767c7f6dce1cf548281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe204ba1224c8767c7f6dce1cf548281">&#9670;&nbsp;</a></span>coda_cursor_goto_array_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_goto_array_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_subs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&#160;</td>
          <td class="paramname"><em>subs</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the cursor to point to an array element via an array of subscripts. This function takes a subscript array to specify the index of the data array element. The length of the array <em>subs</em>, the number of dimensions of the data array and the value of <em>num_subs</em> should all be the same. </p><dl class="section note"><dt>Note</dt><dd>In contrast to <a class="el" href="group__coda__cursor.html#ga08300afc8797ef5bba44b2acb316bdaf">coda_cursor_goto_array_element_by_index()</a> this function will always perform a boundary check on the <em>num_subs</em> and <em>subs</em> parameters, even if the option to check boundaries was turned off with <a class="el" href="group__coda__general.html#ga5d7dcdb4e6b3e6fa1bbf1981b14bb371">coda_set_option_perform_boundary_checks()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor that references an array. </td></tr>
    <tr><td class="paramname">num_subs</td><td>Size of the parameter <em>subs</em>. This should be equal to the number of dimensions of the array which the cursor is pointing to. </td></tr>
    <tr><td class="paramname">subs</td><td>Array of subscripts that identifies the data array element ((0, 0, ..., 0) &lt;= <em>subs</em> &lt; data array dimensions) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga08300afc8797ef5bba44b2acb316bdaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08300afc8797ef5bba44b2acb316bdaf">&#9670;&nbsp;</a></span>coda_cursor_goto_array_element_by_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_goto_array_element_by_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the cursor to point to an array element via an index. This function treats all multidimensional arrays as a one dimensional array (with the same number of elements). The ordering in such a one dimensional array is by definition chosen to be equal to the way the array elements are stored as a sequence in the product file. The mapping of a one dimensional index for each multidimensional data array to an array of subscripts (and vice versa) is defined in such a way that the last element of a subscript array is the one that is the fastest running index (i.e. C array ordering). All multidimensional arrays have their dimensions defined using C array ordering in CODA.<br  />
 For example if we have a two dimensional array with dimensions (2,4) then the index 0 would map to the subscript array (0, 0). 1 would map to (0, 1), 4 would map to (1, 0) and 7 would map to (1, 3). <br  />
 If the data array is one dimensional then this function will have the same result as calling <a class="el" href="group__coda__cursor.html#gabe204ba1224c8767c7f6dce1cf548281">coda_cursor_goto_array_element()</a> with <em>num_subs</em> = 1 and <em>subs</em>[0] = <em>index</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor that references an array. </td></tr>
    <tr><td class="paramname">index</td><td>Index of the array element (0 &lt;= <em>index</em> &lt; number of elements) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaf89949182ab2c80f2fd7705954780141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf89949182ab2c80f2fd7705954780141">&#9670;&nbsp;</a></span>coda_cursor_goto_attributes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_goto_attributes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the cursor to point to a (virtual) record containing the attributes of the current data element. This function will move the cursor to a record containing all attributes of the data element that the cursor was previously pointing to. If there are no attributes available the cursor will point to an empty record (i.e. a record with 0 fields). It only makes sense to retrieve attributes when the HDF4, HDF5, netCDF or XML backend is used. Ascii and binary files will always return an empty record. You can use the CODA Type functions to retrieve the fixed attributes (such as unit and description) for files that are stored in a structured ascii or binary format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gab6a9c2d77774bf323f98267c8918a4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6a9c2d77774bf323f98267c8918a4ba">&#9670;&nbsp;</a></span>coda_cursor_goto_available_union_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_goto_available_union_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the cursor to point to the available union field. CODA treats unions as a special kind of records (i.e. unions are records where all fields are dynamically available and only one field will be available at a time). You can use the <a class="el" href="group__coda__types.html#ga6d6624197f226411f0b063ab3eb554b2">coda_type_get_record_union_status()</a> to determine whether a record is a union. If it is, you can use the <a class="el" href="group__coda__cursor.html#gab6a9c2d77774bf323f98267c8918a4ba">coda_cursor_goto_available_union_field()</a> function to go to the single available record field. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor that references a union record. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga90362bd9b257866af5373f43947925f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90362bd9b257866af5373f43947925f4">&#9670;&nbsp;</a></span>coda_cursor_goto_first_array_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_goto_first_array_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the cursor to point to the first element of an array. For an n-dimensional array this means going to the element with index (0, 0, ..., 0). </p><dl class="section warning"><dt>Warning</dt><dd>If the array has 0 elements then this function will return an error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor that references an array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gadc5a15560bc592b23118d05c44dd56fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc5a15560bc592b23118d05c44dd56fa">&#9670;&nbsp;</a></span>coda_cursor_goto_first_record_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_goto_first_record_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the cursor to point to the first field of a record. If the field is a dynamically available record field and if it is not available in the current record, the cursor will point to a special no-data data type after completion of this function (the position information of the cursor is retained in that case, so you can still use coda_cursor_goto_parent, coda_cursor_goto_next_record_field, etc.). </p><dl class="section warning"><dt>Warning</dt><dd>If the record contains no fields the function will return an error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor that references a record. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaf0251269bb9774efc232cf6771ca9692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0251269bb9774efc232cf6771ca9692">&#9670;&nbsp;</a></span>coda_cursor_goto_next_array_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_goto_next_array_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the cursor to point to the next element of an array. This function treats all multidimensional arrays as a one dimensional array in the same way as <a class="el" href="group__coda__cursor.html#ga08300afc8797ef5bba44b2acb316bdaf">coda_cursor_goto_array_element_by_index()</a> does. It will move the cursor to the array element with <em>index</em> = <em>current_index</em> + 1. </p><dl class="section warning"><dt>Warning</dt><dd>If the cursor already points to the last element of an array the function will return an error. So if you want to enumerate all elements of an array (as a one dimensional sequence) use something like <div class="fragment"><div class="line"><a class="code" href="group__coda__cursor.html#gab9e4cc79aea8d6f50f8406c2fddc66c8">coda_cursor_get_num_elements</a>(cursor, &amp;num_elements);</div>
<div class="line"><span class="keywordflow">if</span> (num_elements &gt; 0)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="group__coda__cursor.html#ga90362bd9b257866af5373f43947925f4">coda_cursor_goto_first_array_element</a>(cursor);</div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; num_elements; i++)</div>
<div class="line">    {</div>
<div class="line">        ...</div>
<div class="line">        <span class="keywordflow">if</span> (i &lt; num_elements - 1)</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="group__coda__cursor.html#gaf0251269bb9774efc232cf6771ca9692">coda_cursor_goto_next_array_element</a>(cursor);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <a class="code" href="group__coda__cursor.html#gadbb9fba27af87d3b854194316a1f8c08">coda_cursor_goto_parent</a>(cursor);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__coda__cursor_html_ga90362bd9b257866af5373f43947925f4"><div class="ttname"><a href="group__coda__cursor.html#ga90362bd9b257866af5373f43947925f4">coda_cursor_goto_first_array_element</a></div><div class="ttdeci">int coda_cursor_goto_first_array_element(coda_cursor *cursor)</div><div class="ttdef"><b>Definition:</b> coda-cursor.c:859</div></div>
<div class="ttc" id="agroup__coda__cursor_html_gab9e4cc79aea8d6f50f8406c2fddc66c8"><div class="ttname"><a href="group__coda__cursor.html#gab9e4cc79aea8d6f50f8406c2fddc66c8">coda_cursor_get_num_elements</a></div><div class="ttdeci">int coda_cursor_get_num_elements(const coda_cursor *cursor, long *num_elements)</div><div class="ttdef"><b>Definition:</b> coda-cursor.c:1695</div></div>
<div class="ttc" id="agroup__coda__cursor_html_gadbb9fba27af87d3b854194316a1f8c08"><div class="ttname"><a href="group__coda__cursor.html#gadbb9fba27af87d3b854194316a1f8c08">coda_cursor_goto_parent</a></div><div class="ttdeci">int coda_cursor_goto_parent(coda_cursor *cursor)</div><div class="ttdef"><b>Definition:</b> coda-cursor.c:1324</div></div>
<div class="ttc" id="agroup__coda__cursor_html_gaf0251269bb9774efc232cf6771ca9692"><div class="ttname"><a href="group__coda__cursor.html#gaf0251269bb9774efc232cf6771ca9692">coda_cursor_goto_next_array_element</a></div><div class="ttdeci">int coda_cursor_goto_next_array_element(coda_cursor *cursor)</div><div class="ttdef"><b>Definition:</b> coda-cursor.c:1123</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor that references an array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga9cfed551f3ad8406b7148f1019c19dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cfed551f3ad8406b7148f1019c19dc2">&#9670;&nbsp;</a></span>coda_cursor_goto_next_record_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_goto_next_record_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the cursor to point to the next field of a record. If the field is a dynamically available record field and if it is not available in the current record, the cursor will point to a special no-data data type after completion of this function (the position information of the cursor is retained in that case, so you can still use coda_cursor_goto_parent, coda_cursor_goto_next_record_field, etc.). </p><dl class="section warning"><dt>Warning</dt><dd>If the cursor already points to the last field of a record the function will return an error. So if you want to enumerate all fields of a record use something like <div class="fragment"><div class="line"><a class="code" href="group__coda__cursor.html#gab9e4cc79aea8d6f50f8406c2fddc66c8">coda_cursor_get_num_elements</a>(cursor, &amp;num_fields);</div>
<div class="line"><span class="keywordflow">if</span> (num_fields &gt; 0)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="group__coda__cursor.html#gadc5a15560bc592b23118d05c44dd56fa">coda_cursor_goto_first_record_field</a>(cursor);</div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; num_fields; i++)</div>
<div class="line">    {</div>
<div class="line">        ...</div>
<div class="line">        <span class="keywordflow">if</span> (i &lt; num_fields - 1)</div>
<div class="line">        {</div>
<div class="line">             <a class="code" href="group__coda__cursor.html#ga9cfed551f3ad8406b7148f1019c19dc2">coda_cursor_goto_next_record_field</a>(cursor);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <a class="code" href="group__coda__cursor.html#gadbb9fba27af87d3b854194316a1f8c08">coda_cursor_goto_parent</a>(cursor);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__coda__cursor_html_ga9cfed551f3ad8406b7148f1019c19dc2"><div class="ttname"><a href="group__coda__cursor.html#ga9cfed551f3ad8406b7148f1019c19dc2">coda_cursor_goto_next_record_field</a></div><div class="ttdeci">int coda_cursor_goto_next_record_field(coda_cursor *cursor)</div><div class="ttdef"><b>Definition:</b> coda-cursor.c:695</div></div>
<div class="ttc" id="agroup__coda__cursor_html_gadc5a15560bc592b23118d05c44dd56fa"><div class="ttname"><a href="group__coda__cursor.html#gadc5a15560bc592b23118d05c44dd56fa">coda_cursor_goto_first_record_field</a></div><div class="ttdeci">int coda_cursor_goto_first_record_field(coda_cursor *cursor)</div><div class="ttdef"><b>Definition:</b> coda-cursor.c:542</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor that references a field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gadbb9fba27af87d3b854194316a1f8c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbb9fba27af87d3b854194316a1f8c08">&#9670;&nbsp;</a></span>coda_cursor_goto_parent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_goto_parent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the cursor one level up in the hierarchy. If the cursor points to a field this function will move the cursor to its record and if the cursor points to an array element the cursor will be moved to the array. If the cursor is already at the topmost level (it points to the root of a product) the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor that references either a field or array element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga73627cc159418db44064525205b78b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73627cc159418db44064525205b78b9a">&#9670;&nbsp;</a></span>coda_cursor_goto_record_field_by_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_goto_record_field_by_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the cursor to point to the field at position <em>index</em> of a record. If the field is a dynamically available record field and if it is not available in the current record, the cursor will point to a special no-data data type after completion of this function (the position information of the cursor is retained in that case, so you can still use coda_cursor_goto_parent, coda_cursor_goto_next_record_field, etc.). </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__coda__cursor.html#gab9e4cc79aea8d6f50f8406c2fddc66c8">coda_cursor_get_num_elements()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor that references a record. </td></tr>
    <tr><td class="paramname">index</td><td>Index of the field (0 &lt;= <em>index</em> &lt; number of fields). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaeaaa4f6eedb6d2463cffc64416de16fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeaaa4f6eedb6d2463cffc64416de16fc">&#9670;&nbsp;</a></span>coda_cursor_goto_record_field_by_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_goto_record_field_by_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the cursor to point to the field of a record that has fieldname <em>name</em>. If the field is a dynamically available record field and if it is not available in the current record, the cursor will point to a special no-data data type after completion of this function (the position information of the cursor is retained in that case, so you can still use coda_cursor_goto_parent, coda_cursor_goto_next_record_field, etc.). If <em>name</em> does not correspond with a fieldname of the record the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor that references a record. </td></tr>
    <tr><td class="paramname">name</td><td>Fieldname of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga1e6ef524e9b26dfa910919905685a078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e6ef524e9b26dfa910919905685a078">&#9670;&nbsp;</a></span>coda_cursor_goto_root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_goto_root </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the cursor to the root of the product. The cursor will be at the same position as it was after its initialization with <a class="el" href="group__coda__cursor.html#ga7c6a6c2bac64e9ab3f9b71d178a3e04d">coda_cursor_set_product()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga78778d16b62c5aa31737e3cd1f2b7f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78778d16b62c5aa31737e3cd1f2b7f2c">&#9670;&nbsp;</a></span>coda_cursor_has_ascii_content()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_has_ascii_content </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>has_ascii_content</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine wether data at the current cursor position is stored as ascii data. You can use this function to determine whether the data is stored in ascii format. If it is in ascii format, you will be able to read the data using <a class="el" href="group__coda__cursor.html#ga192bf0ab48a969fffd50e1d9b611d9b0">coda_cursor_read_string()</a>. If, for instance, a record consists of purely ascii data (i.e. it is a structured ascii block in the file) <em>has_ascii_content</em> for a cursor pointing to that record will be 1 and you can use the <a class="el" href="group__coda__cursor.html#ga192bf0ab48a969fffd50e1d9b611d9b0">coda_cursor_read_string()</a> function to read the whole record as a block of raw ascii. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a valid CODA cursor. </td></tr>
    <tr><td class="paramname">has_ascii_content</td><td>Pointer to a variable where the ascii content status will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga92e3c49aac0ab643fc1a618a5438debe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92e3c49aac0ab643fc1a618a5438debe">&#9670;&nbsp;</a></span>coda_cursor_has_attributes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_has_attributes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>has_attributes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine whether data at the current cursor position has any attributes. If <a class="el" href="group__coda__cursor.html#gaf89949182ab2c80f2fd7705954780141">coda_cursor_goto_attributes()</a> will point to a record that has one or more fields then <em>has_attributes</em> will be set to 1, otherwise it will be set to 0. Note that this has the same result as calling <a class="el" href="group__coda__types.html#ga682a957fd2ba53edbab6219394cbf7d3">coda_type_has_attributes()</a> with the result from <a class="el" href="group__coda__cursor.html#ga6f9f142b7b7adc422587f08bd9c17e07">coda_cursor_get_type()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a valid CODA cursor. </td></tr>
    <tr><td class="paramname">has_attributes</td><td>Pointer to the variable where attribute availability status will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga6cc6cb89a9b6ce8643cc59dae36d665c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cc6cb89a9b6ce8643cc59dae36d665c">&#9670;&nbsp;</a></span>coda_cursor_print_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_print_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const char *,...)&#160;</td>
          <td class="paramname"><em>print</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the full path of the current cursor position using a printf compatible function. The <em>print</em> function parameter should be a function that resembles printf(). The most common case use is to just use printf() itself. For example: </p><div class="fragment"><div class="line"><a class="code" href="group__coda__cursor.html#ga6cc6cb89a9b6ce8643cc59dae36d665c">coda_cursor_print_path</a>(cursor, printf);</div>
<div class="ttc" id="agroup__coda__cursor_html_ga6cc6cb89a9b6ce8643cc59dae36d665c"><div class="ttname"><a href="group__coda__cursor.html#ga6cc6cb89a9b6ce8643cc59dae36d665c">coda_cursor_print_path</a></div><div class="ttdeci">int coda_cursor_print_path(const coda_cursor *cursor, int(*print)(const char *,...))</div><div class="ttdef"><b>Definition:</b> coda-cursor.c:235</div></div>
</div><!-- fragment --><p> The format of the printed path is the same as used for nodes in <a class="el" href="group__coda__expression.html">CODA expressions </a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">print</td><td>Reference to a printf compatible function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Succes. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga2a3671533d5d82a66e3d8ced808d7c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a3671533d5d82a66e3d8ced808d7c07">&#9670;&nbsp;</a></span>coda_cursor_read_bits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_bits </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>bit_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>bit_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a specified amount of bits. The data is stored in <em>dst</em>. This function will work independent of the type of data at the current cursor position, but it will not work on ASCII, XML, HDF4, and HDF5 data. The function will read a <em>bit_length</em> amount of bits starting from the sum of the cursor offset position and the amount of bits given by the <em>bit_offset</em> parameter. If <em>bit_length</em> is not a rounded amount of bytes the data will be put in the first <em>bit_length/8</em> + 1 bytes and will be right adjusted (i.e. padding bits with value 0 will be put in the most significant bits of the first byte of <em>dst</em>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the value that was read from the product will be stored. </td></tr>
    <tr><td class="paramname">bit_offset</td><td>The offset relative to the current cursor position from where the bits should be read. </td></tr>
    <tr><td class="paramname">bit_length</td><td>The number of bits to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaaa38cba1ab7f02e48d9f27e1117368ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa38cba1ab7f02e48d9f27e1117368ee">&#9670;&nbsp;</a></span>coda_cursor_read_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_bytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a specified amount of bytes. The data is stored in <em>dst</em>. This function will work independent of the type of data at the current cursor position, but it will not work on HDF4 and HDF5 files. For XML files it will only work if the cursor points to a single element (i.e. you will get an error when the cursor points to an XML element array or an attribute record). The function will read a <em>length</em> amount of bytes starting from the sum of the cursor offset position and the amount of bytes given by the <em>offset</em> parameter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the value that was read from the product will be stored. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset relative to the current cursor position from where the bytes should be read. </td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga7416cf18a02b88bff5d978d1eefbbd31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7416cf18a02b88bff5d978d1eefbbd31">&#9670;&nbsp;</a></span>coda_cursor_read_char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_char </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve data as type <code>char</code> from the product file. The value is stored in <em>dst</em>. The cursor must point to data with read type <code>char</code> to succeed. For all other data types the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the value that was read from the product will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gae6ea0599122ae7b2249a4240f82d0a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6ea0599122ae7b2249a4240f82d0a2c">&#9670;&nbsp;</a></span>coda_cursor_read_char_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_char_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__coda__general.html#ga43bbecf10194ddde79f34f1111b7597c">coda_array_ordering</a>&#160;</td>
          <td class="paramname"><em>array_ordering</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a data array as type <code>char</code> from the product file. The values are stored in <em>dst</em>. The cursor must point to an array with a base type that has read type <code>char</code> to succeed. For all other data types the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the values read from the product will be stored. </td></tr>
    <tr><td class="paramname">array_ordering</td><td>Specifies array storage ordering for <em>dst:</em> must be <a class="el" href="group__coda__general.html#gga5585c4e41c797b14f3dd4ac5f5e20ec7a3bb5ab26bb40b1597da2eafbd8e46454">coda_array_ordering_c</a> or <a class="el" href="group__coda__general.html#gga5585c4e41c797b14f3dd4ac5f5e20ec7a6f530dfe688c288f37ff5bbe2ce1e95b">coda_array_ordering_fortran</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga8572c07adc0d9b11b4da580cd7fcd548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8572c07adc0d9b11b4da580cd7fcd548">&#9670;&nbsp;</a></span>coda_cursor_read_char_partial_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_char_partial_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a partial data array as type <code>char</code> from the product file. The values are stored in <em>dst</em>. The cursor must point to an array with a base type that has read type <code>char</code> to succeed. For all other data types the function will return an error. Values are both read and returned using C array ordering convention. </p><dl class="section note"><dt>Note</dt><dd>Partial array reading is not supported for HDF5 and HDF4 attributes and HDF4 Vdata. For HDF5 Datasets, HDF4 SDS, and HDF4 GRImage, partial array reading is only allowed when reading a full hyperslab (i.e. the range defined by 'offset' and 'length' should be translatable into a multidimensional start[]/count[], defining a hyperslab) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">offset</td><td>Index (as used in <a class="el" href="group__coda__cursor.html#ga08300afc8797ef5bba44b2acb316bdaf">coda_cursor_goto_array_element_by_index</a>) at which to start reading. </td></tr>
    <tr><td class="paramname">length</td><td>Number of items to read. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the values read from the product will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga079c36f25a4d4dcc87844e7fde47fefc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga079c36f25a4d4dcc87844e7fde47fefc">&#9670;&nbsp;</a></span>coda_cursor_read_complex_double_pair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_complex_double_pair </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve complex data as type <code>double</code> from the product file. The real and imaginary values are stored consecutively in <em>dst</em>. The cursor must point to data with special type <a class="el" href="group__coda__types.html#ggab0124a9650f42b5f4eb2eb21535539eba7298ffbdd7d5618689d4183c3e3de865">coda_special_complex</a> to succeed. For all other data types the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the value that was read from the product will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gac0fd573997d9526199034333905d8012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0fd573997d9526199034333905d8012">&#9670;&nbsp;</a></span>coda_cursor_read_complex_double_pairs_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_complex_double_pairs_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__coda__general.html#ga43bbecf10194ddde79f34f1111b7597c">coda_array_ordering</a>&#160;</td>
          <td class="paramname"><em>array_ordering</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve an array of complex data as type <code>double</code> from the product file. All complex array elements are stored consecutively in <em>dst</em> (for each element the real and imaginary values are stored next to each other). The cursor must point to data with a base type that has special type <a class="el" href="group__coda__types.html#ggab0124a9650f42b5f4eb2eb21535539eba7298ffbdd7d5618689d4183c3e3de865">coda_special_complex</a> to succeed. For all other data types the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the values read from the product will be stored. </td></tr>
    <tr><td class="paramname">array_ordering</td><td>Specifies array storage ordering for <em>dst:</em> must be <a class="el" href="group__coda__general.html#gga5585c4e41c797b14f3dd4ac5f5e20ec7a3bb5ab26bb40b1597da2eafbd8e46454">coda_array_ordering_c</a> or <a class="el" href="group__coda__general.html#gga5585c4e41c797b14f3dd4ac5f5e20ec7a6f530dfe688c288f37ff5bbe2ce1e95b">coda_array_ordering_fortran</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga011d3964e1768f34c7decbce68af5b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga011d3964e1768f34c7decbce68af5b51">&#9670;&nbsp;</a></span>coda_cursor_read_complex_double_split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_complex_double_split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dst_re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dst_im</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve complex data as type <code>double</code> from the product file. The real and imaginary values are stored in <em>dst_re</em> and <em>dst_im</em>. The cursor must point to data with special type <a class="el" href="group__coda__types.html#ggab0124a9650f42b5f4eb2eb21535539eba7298ffbdd7d5618689d4183c3e3de865">coda_special_complex</a> to succeed. For all other data types the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">dst_re</td><td>Pointer to the variable where the real value that was read from the product will be stored. </td></tr>
    <tr><td class="paramname">dst_im</td><td>Pointer to the variable where the imaginary value that was read from the product will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga496a8360cb05ddc771a4ec54b4f711f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga496a8360cb05ddc771a4ec54b4f711f8">&#9670;&nbsp;</a></span>coda_cursor_read_complex_double_split_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_complex_double_split_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dst_re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dst_im</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__coda__general.html#ga43bbecf10194ddde79f34f1111b7597c">coda_array_ordering</a>&#160;</td>
          <td class="paramname"><em>array_ordering</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve an array of complex data as type <code>double</code> from the product file. All real array elements are stored in <em>dst_re</em> and all imaginary array elements in <em>dsr_im</em>. The cursor must point to data with a base type that has special type <a class="el" href="group__coda__types.html#ggab0124a9650f42b5f4eb2eb21535539eba7298ffbdd7d5618689d4183c3e3de865">coda_special_complex</a> to succeed. For all other data types the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">dst_re</td><td>Pointer to the variable where the real values read from the product will be stored. </td></tr>
    <tr><td class="paramname">dst_im</td><td>Pointer to the variable where the imaginary values read from the product will be stored. </td></tr>
    <tr><td class="paramname">array_ordering</td><td>Specifies array storage ordering for <em>dst_im</em> and <em>dst_re:</em> must be <a class="el" href="group__coda__general.html#gga5585c4e41c797b14f3dd4ac5f5e20ec7a3bb5ab26bb40b1597da2eafbd8e46454">coda_array_ordering_c</a> or <a class="el" href="group__coda__general.html#gga5585c4e41c797b14f3dd4ac5f5e20ec7a6f530dfe688c288f37ff5bbe2ce1e95b">coda_array_ordering_fortran</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gab4aa54ab5f18c8827435c834dc0415f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4aa54ab5f18c8827435c834dc0415f9">&#9670;&nbsp;</a></span>coda_cursor_read_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_double </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve data as type <code>double</code> from the product file. The value is stored in <em>dst</em>. The cursor must point to data with one of the following read types to succeed:</p><ul>
<li><code>int8</code> </li>
<li><code>uint8</code> </li>
<li><code>int16</code> </li>
<li><code>uint16</code> </li>
<li><code>int32</code> </li>
<li><code>uint32</code> </li>
<li><code>int64</code> </li>
<li><code>uint64</code> </li>
<li><code>float</code> </li>
<li><code>double</code> </li>
</ul>
<p>For all other data types the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the value that was read from the product will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga98a4ed2ffa4dd5d063604ebdfc1b9c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98a4ed2ffa4dd5d063604ebdfc1b9c6b">&#9670;&nbsp;</a></span>coda_cursor_read_double_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_double_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__coda__general.html#ga43bbecf10194ddde79f34f1111b7597c">coda_array_ordering</a>&#160;</td>
          <td class="paramname"><em>array_ordering</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a data array as type <code>double</code> from the product file. The values are stored in <em>dst</em>. The cursor must point to an array with a base type that has one of the following read types to succeed:</p><ul>
<li><code>int8</code> </li>
<li><code>uint8</code> </li>
<li><code>int16</code> </li>
<li><code>uint16</code> </li>
<li><code>int32</code> </li>
<li><code>uint32</code> </li>
<li><code>int64</code> </li>
<li><code>uint64</code> </li>
<li><code>float</code> </li>
<li><code>double</code> </li>
</ul>
<p>For all other data types the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the values read from the product will be stored. </td></tr>
    <tr><td class="paramname">array_ordering</td><td>Specifies array storage ordering for <em>dst:</em> must be <a class="el" href="group__coda__general.html#gga5585c4e41c797b14f3dd4ac5f5e20ec7a3bb5ab26bb40b1597da2eafbd8e46454">coda_array_ordering_c</a> or <a class="el" href="group__coda__general.html#gga5585c4e41c797b14f3dd4ac5f5e20ec7a6f530dfe688c288f37ff5bbe2ce1e95b">coda_array_ordering_fortran</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gadb02ac86d877f6cd2e88416e64347a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb02ac86d877f6cd2e88416e64347a31">&#9670;&nbsp;</a></span>coda_cursor_read_double_partial_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_double_partial_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a partial data array as type <code>double</code> from the product file. The values are stored in <em>dst</em>. The cursor must point to an array with a base type that has one of the following read types to succeed:</p><ul>
<li><code>int8</code> </li>
<li><code>uint8</code> </li>
<li><code>int16</code> </li>
<li><code>uint16</code> </li>
<li><code>int32</code> </li>
<li><code>uint32</code> </li>
<li><code>int64</code> </li>
<li><code>uint64</code> </li>
<li><code>float</code> </li>
<li><code>double</code> </li>
</ul>
<p>For all other data types the function will return an error. Values are both read and returned using C array ordering convention. </p><dl class="section note"><dt>Note</dt><dd>Partial array reading is not supported for HDF5 and HDF4 attributes and HDF4 Vdata. For HDF5 Datasets, HDF4 SDS, and HDF4 GRImage, partial array reading is only allowed when reading a full hyperslab (i.e. the range defined by 'offset' and 'length' should be translatable into a multidimensional start[]/count[], defining a hyperslab) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">offset</td><td>Index (as used in <a class="el" href="group__coda__cursor.html#ga08300afc8797ef5bba44b2acb316bdaf">coda_cursor_goto_array_element_by_index</a>) at which to start reading. </td></tr>
    <tr><td class="paramname">length</td><td>Number of items to read. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the values read from the product will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga4b9f163bcdca6ee0ae02c3c16f1aa15c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b9f163bcdca6ee0ae02c3c16f1aa15c">&#9670;&nbsp;</a></span>coda_cursor_read_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_float </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve data as type <code>float</code> from the product file. The value is stored in <em>dst</em>. The cursor must point to data with one of the following read types to succeed:</p><ul>
<li><code>int8</code> </li>
<li><code>uint8</code> </li>
<li><code>int16</code> </li>
<li><code>uint16</code> </li>
<li><code>int32</code> </li>
<li><code>uint32</code> </li>
<li><code>int64</code> </li>
<li><code>uint64</code> </li>
<li><code>float</code> </li>
<li><code>double</code> </li>
</ul>
<p>For all other data types the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the value that was read from the product will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaa7563628d9041a15bd28e0f738af29c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7563628d9041a15bd28e0f738af29c3">&#9670;&nbsp;</a></span>coda_cursor_read_float_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_float_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__coda__general.html#ga43bbecf10194ddde79f34f1111b7597c">coda_array_ordering</a>&#160;</td>
          <td class="paramname"><em>array_ordering</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a data array as type <code>float</code> from the product file. The values are stored in <em>dst</em>. The cursor must point to an array with a base type that has one of the following read types to succeed:</p><ul>
<li><code>int8</code> </li>
<li><code>uint8</code> </li>
<li><code>int16</code> </li>
<li><code>uint16</code> </li>
<li><code>int32</code> </li>
<li><code>uint32</code> </li>
<li><code>int64</code> </li>
<li><code>uint64</code> </li>
<li><code>float</code> </li>
<li><code>double</code> </li>
</ul>
<p>For all other data types the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the values read from the product will be stored. </td></tr>
    <tr><td class="paramname">array_ordering</td><td>Specifies array storage ordering for <em>dst:</em> must be <a class="el" href="group__coda__general.html#gga5585c4e41c797b14f3dd4ac5f5e20ec7a3bb5ab26bb40b1597da2eafbd8e46454">coda_array_ordering_c</a> or <a class="el" href="group__coda__general.html#gga5585c4e41c797b14f3dd4ac5f5e20ec7a6f530dfe688c288f37ff5bbe2ce1e95b">coda_array_ordering_fortran</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gac276c2ea6e31974ea6b809cc0fbf3953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac276c2ea6e31974ea6b809cc0fbf3953">&#9670;&nbsp;</a></span>coda_cursor_read_float_partial_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_float_partial_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a partial data array as type <code>float</code> from the product file. The values are stored in <em>dst</em>. The cursor must point to an array with a base type that has one of the following read types to succeed:</p><ul>
<li><code>int8</code> </li>
<li><code>uint8</code> </li>
<li><code>int16</code> </li>
<li><code>uint16</code> </li>
<li><code>int32</code> </li>
<li><code>uint32</code> </li>
<li><code>int64</code> </li>
<li><code>uint64</code> </li>
<li><code>float</code> </li>
<li><code>double</code> </li>
</ul>
<p>For all other data types the function will return an error. Values are both read and returned using C array ordering convention. </p><dl class="section note"><dt>Note</dt><dd>Partial array reading is not supported for HDF5 and HDF4 attributes and HDF4 Vdata. For HDF5 Datasets, HDF4 SDS, and HDF4 GRImage, partial array reading is only allowed when reading a full hyperslab (i.e. the range defined by 'offset' and 'length' should be translatable into a multidimensional start[]/count[], defining a hyperslab) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">offset</td><td>Index (as used in <a class="el" href="group__coda__cursor.html#ga08300afc8797ef5bba44b2acb316bdaf">coda_cursor_goto_array_element_by_index</a>) at which to start reading. </td></tr>
    <tr><td class="paramname">length</td><td>Number of items to read. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the values read from the product will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga9d5ceb277c7d281b790b371d67e0a082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d5ceb277c7d281b790b371d67e0a082">&#9670;&nbsp;</a></span>coda_cursor_read_int16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_int16 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve data as type <code>int16</code> from the product file. The value is stored in <em>dst</em>. The cursor must point to data with one of the following read types to succeed:</p><ul>
<li><code>int8</code> </li>
<li><code>uint8</code> </li>
<li><code>int16</code> </li>
</ul>
<p>For all other data types the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the value that was read from the product will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaae57bdba87431cddbcb9e5b9c114afad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae57bdba87431cddbcb9e5b9c114afad">&#9670;&nbsp;</a></span>coda_cursor_read_int16_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_int16_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__coda__general.html#ga43bbecf10194ddde79f34f1111b7597c">coda_array_ordering</a>&#160;</td>
          <td class="paramname"><em>array_ordering</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a data array as type <code>int16</code> from the product file. The values are stored in <em>dst</em>. The cursor must point to an array with a base type that has one of the following read types to succeed:</p><ul>
<li><code>int8</code> </li>
<li><code>uint8</code> </li>
<li><code>int16</code> </li>
</ul>
<p>For all other data types the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the values read from the product will be stored. </td></tr>
    <tr><td class="paramname">array_ordering</td><td>Specifies array storage ordering for <em>dst:</em> must be <a class="el" href="group__coda__general.html#gga5585c4e41c797b14f3dd4ac5f5e20ec7a3bb5ab26bb40b1597da2eafbd8e46454">coda_array_ordering_c</a> or <a class="el" href="group__coda__general.html#gga5585c4e41c797b14f3dd4ac5f5e20ec7a6f530dfe688c288f37ff5bbe2ce1e95b">coda_array_ordering_fortran</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga7e78a84fb20d59336055d402f2b7b830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e78a84fb20d59336055d402f2b7b830">&#9670;&nbsp;</a></span>coda_cursor_read_int16_partial_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_int16_partial_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a partial data array as type <code>int16</code> from the product file. The values are stored in <em>dst</em>. The cursor must point to an array with a base type that has one of the following read types to succeed:</p><ul>
<li><code>int8</code> </li>
<li><code>uint8</code> </li>
<li><code>int16</code> </li>
</ul>
<p>For all other data types the function will return an error. Values are both read and returned using C array ordering convention. </p><dl class="section note"><dt>Note</dt><dd>Partial array reading is not supported for HDF5 and HDF4 attributes and HDF4 Vdata. For HDF5 Datasets, HDF4 SDS, and HDF4 GRImage, partial array reading is only allowed when reading a full hyperslab (i.e. the range defined by 'offset' and 'length' should be translatable into a multidimensional start[]/count[], defining a hyperslab) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">offset</td><td>Index (as used in <a class="el" href="group__coda__cursor.html#ga08300afc8797ef5bba44b2acb316bdaf">coda_cursor_goto_array_element_by_index</a>) at which to start reading. </td></tr>
    <tr><td class="paramname">length</td><td>Number of items to read. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the values read from the product will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga273251b8b1c9ab5d6f2a23a9d5c150a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga273251b8b1c9ab5d6f2a23a9d5c150a1">&#9670;&nbsp;</a></span>coda_cursor_read_int32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_int32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve data as type <code>int32</code> from the product file. The value is stored in <em>dst</em>. The cursor must point to data with one of the following read types to succeed:</p><ul>
<li><code>int8</code> </li>
<li><code>uint8</code> </li>
<li><code>int16</code> </li>
<li><code>uint16</code> </li>
<li><code>int32</code> </li>
</ul>
<p>For all other data types the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the value that was read from the product will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga216a586c7e1dbc9c66673635a1a279cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga216a586c7e1dbc9c66673635a1a279cb">&#9670;&nbsp;</a></span>coda_cursor_read_int32_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_int32_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__coda__general.html#ga43bbecf10194ddde79f34f1111b7597c">coda_array_ordering</a>&#160;</td>
          <td class="paramname"><em>array_ordering</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a data array as type <code>int32</code> from the product file. The values are stored in <em>dst</em>. The cursor must point to an array with a base type that has one of the following read types to succeed:</p><ul>
<li><code>int8</code> </li>
<li><code>uint8</code> </li>
<li><code>int16</code> </li>
<li><code>uint16</code> </li>
<li><code>int32</code> </li>
</ul>
<p>For all other data types the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the values read from the product will be stored. </td></tr>
    <tr><td class="paramname">array_ordering</td><td>Specifies array storage ordering for <em>dst:</em> must be <a class="el" href="group__coda__general.html#gga5585c4e41c797b14f3dd4ac5f5e20ec7a3bb5ab26bb40b1597da2eafbd8e46454">coda_array_ordering_c</a> or <a class="el" href="group__coda__general.html#gga5585c4e41c797b14f3dd4ac5f5e20ec7a6f530dfe688c288f37ff5bbe2ce1e95b">coda_array_ordering_fortran</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga5c684d94f67f3e8bc6126be989f6cf04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c684d94f67f3e8bc6126be989f6cf04">&#9670;&nbsp;</a></span>coda_cursor_read_int32_partial_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_int32_partial_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a partial data array as type <code>int32</code> from the product file. The values are stored in <em>dst</em>. The cursor must point to an array with a base type that has one of the following read types to succeed:</p><ul>
<li><code>int8</code> </li>
<li><code>uint8</code> </li>
<li><code>int16</code> </li>
<li><code>uint16</code> </li>
<li><code>int32</code> </li>
</ul>
<p>For all other data types the function will return an error. Values are both read and returned using C array ordering convention. </p><dl class="section note"><dt>Note</dt><dd>Partial array reading is not supported for HDF5 and HDF4 attributes and HDF4 Vdata. For HDF5 Datasets, HDF4 SDS, and HDF4 GRImage, partial array reading is only allowed when reading a full hyperslab (i.e. the range defined by 'offset' and 'length' should be translatable into a multidimensional start[]/count[], defining a hyperslab) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">offset</td><td>Index (as used in <a class="el" href="group__coda__cursor.html#ga08300afc8797ef5bba44b2acb316bdaf">coda_cursor_goto_array_element_by_index</a>) at which to start reading. </td></tr>
    <tr><td class="paramname">length</td><td>Number of items to read. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the values read from the product will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gabab325db9c84ad553adf6a5b6e65bca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabab325db9c84ad553adf6a5b6e65bca5">&#9670;&nbsp;</a></span>coda_cursor_read_int64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_int64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve data as type <code>int64</code> from the product file. The value is stored in <em>dst</em>. The cursor must point to data with one of the following read types to succeed:</p><ul>
<li><code>int8</code> </li>
<li><code>uint8</code> </li>
<li><code>int16</code> </li>
<li><code>uint16</code> </li>
<li><code>int32</code> </li>
<li><code>uint32</code> </li>
<li><code>int64</code> </li>
</ul>
<p>For all other data types the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the value that was read from the product will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga685b5a2e3bec4bee7bf48bc99971fbb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga685b5a2e3bec4bee7bf48bc99971fbb2">&#9670;&nbsp;</a></span>coda_cursor_read_int64_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_int64_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__coda__general.html#ga43bbecf10194ddde79f34f1111b7597c">coda_array_ordering</a>&#160;</td>
          <td class="paramname"><em>array_ordering</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a data array as type <code>int64</code> from the product file. The values are stored in <em>dst</em>. The cursor must point to an array with a base type that has one of the following read types to succeed:</p><ul>
<li><code>int8</code> </li>
<li><code>uint8</code> </li>
<li><code>int16</code> </li>
<li><code>uint16</code> </li>
<li><code>int32</code> </li>
<li><code>uint32</code> </li>
<li><code>int64</code> </li>
</ul>
<p>For all other data types the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the values read from the product will be stored. </td></tr>
    <tr><td class="paramname">array_ordering</td><td>Specifies array storage ordering for <em>dst:</em> must be <a class="el" href="group__coda__general.html#gga5585c4e41c797b14f3dd4ac5f5e20ec7a3bb5ab26bb40b1597da2eafbd8e46454">coda_array_ordering_c</a> or <a class="el" href="group__coda__general.html#gga5585c4e41c797b14f3dd4ac5f5e20ec7a6f530dfe688c288f37ff5bbe2ce1e95b">coda_array_ordering_fortran</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga6abbc189207419e23de2c26eea21cebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6abbc189207419e23de2c26eea21cebc">&#9670;&nbsp;</a></span>coda_cursor_read_int64_partial_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_int64_partial_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a partial data array as type <code>int64</code> from the product file. The values are stored in <em>dst</em>. The cursor must point to an array with a base type that has one of the following read types to succeed:</p><ul>
<li><code>int8</code> </li>
<li><code>uint8</code> </li>
<li><code>int16</code> </li>
<li><code>uint16</code> </li>
<li><code>int32</code> </li>
<li><code>uint32</code> </li>
<li><code>int64</code> </li>
</ul>
<p>For all other data types the function will return an error. Values are both read and returned using C array ordering convention. </p><dl class="section note"><dt>Note</dt><dd>Partial array reading is not supported for HDF5 and HDF4 attributes and HDF4 Vdata. For HDF5 Datasets, HDF4 SDS, and HDF4 GRImage, partial array reading is only allowed when reading a full hyperslab (i.e. the range defined by 'offset' and 'length' should be translatable into a multidimensional start[]/count[], defining a hyperslab) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">offset</td><td>Index (as used in <a class="el" href="group__coda__cursor.html#ga08300afc8797ef5bba44b2acb316bdaf">coda_cursor_goto_array_element_by_index</a>) at which to start reading. </td></tr>
    <tr><td class="paramname">length</td><td>Number of items to read. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the values read from the product will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gab8f98f432a0be7844f8e9f2bf54d8173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8f98f432a0be7844f8e9f2bf54d8173">&#9670;&nbsp;</a></span>coda_cursor_read_int8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_int8 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve data as type <code>int8</code> from the product file. The value is stored in <em>dst</em>. The cursor must point to data with one of the following read types to succeed:</p><ul>
<li><code>int8</code> </li>
</ul>
<p>For all other data types the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the value that was read from the product will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga8b2e3f9f049e53f665326c177f781844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b2e3f9f049e53f665326c177f781844">&#9670;&nbsp;</a></span>coda_cursor_read_int8_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_int8_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__coda__general.html#ga43bbecf10194ddde79f34f1111b7597c">coda_array_ordering</a>&#160;</td>
          <td class="paramname"><em>array_ordering</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a data array as type <code>int8</code> from the product file. The values are stored in <em>dst</em>. The cursor must point to an array with a base type that has one of the following read types to succeed:</p><ul>
<li><code>int8</code> </li>
</ul>
<p>For all other data types the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the values read from the product will be stored. </td></tr>
    <tr><td class="paramname">array_ordering</td><td>Specifies array storage ordering for <em>dst:</em> must be <a class="el" href="group__coda__general.html#gga5585c4e41c797b14f3dd4ac5f5e20ec7a3bb5ab26bb40b1597da2eafbd8e46454">coda_array_ordering_c</a> or <a class="el" href="group__coda__general.html#gga5585c4e41c797b14f3dd4ac5f5e20ec7a6f530dfe688c288f37ff5bbe2ce1e95b">coda_array_ordering_fortran</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga9f223be340986a3bcf66d51622e65745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f223be340986a3bcf66d51622e65745">&#9670;&nbsp;</a></span>coda_cursor_read_int8_partial_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_int8_partial_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a partial data array as type <code>int8</code> from the product file. The values are stored in <em>dst</em>. The cursor must point to an array with a base type that has one of the following read types to succeed:</p><ul>
<li><code>int8</code> </li>
</ul>
<p>For all other data types the function will return an error. Values are both read and returned using C array ordering convention. </p><dl class="section note"><dt>Note</dt><dd>Partial array reading is not supported for HDF5 and HDF4 attributes and HDF4 Vdata. For HDF5 Datasets, HDF4 SDS, and HDF4 GRImage, partial array reading is only allowed when reading a full hyperslab (i.e. the range defined by 'offset' and 'length' should be translatable into a multidimensional start[]/count[], defining a hyperslab) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">offset</td><td>Index (as used in <a class="el" href="group__coda__cursor.html#ga08300afc8797ef5bba44b2acb316bdaf">coda_cursor_goto_array_element_by_index</a>) at which to start reading. </td></tr>
    <tr><td class="paramname">length</td><td>Number of items to read. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the values read from the product will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga192bf0ab48a969fffd50e1d9b611d9b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga192bf0ab48a969fffd50e1d9b611d9b0">&#9670;&nbsp;</a></span>coda_cursor_read_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>dst_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve text data as a 0 terminated string. The value is stored in <em>dst</em>. You will be able to read data as a string if the cursor points to data with type class <a class="el" href="group__coda__types.html#ggaa4d9bef64d23de166a5e0249504f5afaa11d9a0b0ca20c41c9b6ebd492ffd3e0a">coda_text_class</a> or if it points to ASCII data (see <a class="el" href="group__coda__cursor.html#ga78778d16b62c5aa31737e3cd1f2b7f2c">coda_cursor_has_ascii_content()</a>). For other cases the function will return an error. The function will fill at most <em>dst_size</em> bytes in the dst memory space. The last character that is put in <em>dst</em> will always be a zero termination character, which means that at most <em>dst_size</em> - 1 characters of text data will be read. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the value that was read from the product will be stored. </td></tr>
    <tr><td class="paramname">dst_size</td><td>The maximum number of bytes to write in <em>dst</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga1cc912a70964acd2c1d2570e9cf165e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cc912a70964acd2c1d2570e9cf165e4">&#9670;&nbsp;</a></span>coda_cursor_read_uint16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_uint16 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve data as type <code>uint16</code> from the product file. The value is stored in <em>dst</em>. The cursor must point to data with one of the following read types to succeed:</p><ul>
<li><code>uint8</code> </li>
<li><code>uint16</code> </li>
</ul>
<p>For all other data types the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the value that was read from the product will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaaec918e87885b76c1654291f383b0b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaec918e87885b76c1654291f383b0b3c">&#9670;&nbsp;</a></span>coda_cursor_read_uint16_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_uint16_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__coda__general.html#ga43bbecf10194ddde79f34f1111b7597c">coda_array_ordering</a>&#160;</td>
          <td class="paramname"><em>array_ordering</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a data array as type <code>uint16</code> from the product file. The values are stored in <em>dst</em>. The cursor must point to an array with a base type that has one of the following read types to succeed:</p><ul>
<li><code>uint8</code> </li>
<li><code>uint16</code> </li>
</ul>
<p>For all other data types the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the values read from the product will be stored. </td></tr>
    <tr><td class="paramname">array_ordering</td><td>Specifies array storage ordering for <em>dst:</em> must be <a class="el" href="group__coda__general.html#gga5585c4e41c797b14f3dd4ac5f5e20ec7a3bb5ab26bb40b1597da2eafbd8e46454">coda_array_ordering_c</a> or <a class="el" href="group__coda__general.html#gga5585c4e41c797b14f3dd4ac5f5e20ec7a6f530dfe688c288f37ff5bbe2ce1e95b">coda_array_ordering_fortran</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga16d83093a7b5d52e4665785b66af0d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16d83093a7b5d52e4665785b66af0d55">&#9670;&nbsp;</a></span>coda_cursor_read_uint16_partial_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_uint16_partial_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a partial data array as type <code>uint16</code> from the product file. The values are stored in <em>dst</em>. The cursor must point to an array with a base type that has one of the following read types to succeed:</p><ul>
<li><code>uint8</code> </li>
<li><code>uint16</code> </li>
</ul>
<p>For all other data types the function will return an error. Values are both read and returned using C array ordering convention. </p><dl class="section note"><dt>Note</dt><dd>Partial array reading is not supported for HDF5 and HDF4 attributes and HDF4 Vdata. For HDF5 Datasets, HDF4 SDS, and HDF4 GRImage, partial array reading is only allowed when reading a full hyperslab (i.e. the range defined by 'offset' and 'length' should be translatable into a multidimensional start[]/count[], defining a hyperslab) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">offset</td><td>Index (as used in <a class="el" href="group__coda__cursor.html#ga08300afc8797ef5bba44b2acb316bdaf">coda_cursor_goto_array_element_by_index</a>) at which to start reading. </td></tr>
    <tr><td class="paramname">length</td><td>Number of items to read. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the values read from the product will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaf1b61767aefb13134c099636dddce7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1b61767aefb13134c099636dddce7c7">&#9670;&nbsp;</a></span>coda_cursor_read_uint32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_uint32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve data as type <code>uint32</code> from the product file. The value is stored in <em>dst</em>. The cursor must point to data with one of the following read types to succeed:</p><ul>
<li><code>uint8</code> </li>
<li><code>uint16</code> </li>
<li><code>uint32</code> </li>
</ul>
<p>For all other data types the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the value that was read from the product will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga6adacbfd82d0af87d53bfcbc2cbb72da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6adacbfd82d0af87d53bfcbc2cbb72da">&#9670;&nbsp;</a></span>coda_cursor_read_uint32_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_uint32_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__coda__general.html#ga43bbecf10194ddde79f34f1111b7597c">coda_array_ordering</a>&#160;</td>
          <td class="paramname"><em>array_ordering</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a data array as type <code>uint32</code> from the product file. The values are stored in <em>dst</em>. The cursor must point to an array with a base type that has one of the following read types to succeed:</p><ul>
<li><code>uint8</code> </li>
<li><code>uint16</code> </li>
<li><code>uint32</code> </li>
</ul>
<p>For all other data types the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the values read from the product will be stored. </td></tr>
    <tr><td class="paramname">array_ordering</td><td>Specifies array storage ordering for <em>dst:</em> must be <a class="el" href="group__coda__general.html#gga5585c4e41c797b14f3dd4ac5f5e20ec7a3bb5ab26bb40b1597da2eafbd8e46454">coda_array_ordering_c</a> or <a class="el" href="group__coda__general.html#gga5585c4e41c797b14f3dd4ac5f5e20ec7a6f530dfe688c288f37ff5bbe2ce1e95b">coda_array_ordering_fortran</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga3d71e54334a42567e7d0680cbd195df0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d71e54334a42567e7d0680cbd195df0">&#9670;&nbsp;</a></span>coda_cursor_read_uint32_partial_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_uint32_partial_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a partial data array as type <code>uint32</code> from the product file. The values are stored in <em>dst</em>. The cursor must point to an array with a base type that has one of the following read types to succeed:</p><ul>
<li><code>uint8</code> </li>
<li><code>uint16</code> </li>
<li><code>uint32</code> </li>
</ul>
<p>For all other data types the function will return an error. Values are both read and returned using C array ordering convention. </p><dl class="section note"><dt>Note</dt><dd>Partial array reading is not supported for HDF5 and HDF4 attributes and HDF4 Vdata. For HDF5 Datasets, HDF4 SDS, and HDF4 GRImage, partial array reading is only allowed when reading a full hyperslab (i.e. the range defined by 'offset' and 'length' should be translatable into a multidimensional start[]/count[], defining a hyperslab) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">offset</td><td>Index (as used in <a class="el" href="group__coda__cursor.html#ga08300afc8797ef5bba44b2acb316bdaf">coda_cursor_goto_array_element_by_index</a>) at which to start reading. </td></tr>
    <tr><td class="paramname">length</td><td>Number of items to read. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the values read from the product will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga940188ac43bc49d7ab829c64b5d94645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga940188ac43bc49d7ab829c64b5d94645">&#9670;&nbsp;</a></span>coda_cursor_read_uint64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_uint64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve data as type <code>uint64</code> from the product file. The value is stored in <em>dst</em>. The cursor must point to data with one of the following read types to succeed:</p><ul>
<li><code>uint8</code> </li>
<li><code>uint16</code> </li>
<li><code>uint32</code> </li>
<li><code>uint64</code> </li>
</ul>
<p>For all other data types the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the value that was read from the product will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga06bfb416cddde9f8e8f67dc827a95b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06bfb416cddde9f8e8f67dc827a95b5e">&#9670;&nbsp;</a></span>coda_cursor_read_uint64_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_uint64_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__coda__general.html#ga43bbecf10194ddde79f34f1111b7597c">coda_array_ordering</a>&#160;</td>
          <td class="paramname"><em>array_ordering</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a data array as type <code>uint64</code> from the product file. The values are stored in <em>dst</em>. The cursor must point to an array with a base type that has one of the following read types to succeed:</p><ul>
<li><code>uint8</code> </li>
<li><code>uint16</code> </li>
<li><code>uint32</code> </li>
<li><code>uint64</code> </li>
</ul>
<p>For all other data types the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the values read from the product will be stored. </td></tr>
    <tr><td class="paramname">array_ordering</td><td>Specifies array storage ordering for <em>dst:</em> must be <a class="el" href="group__coda__general.html#gga5585c4e41c797b14f3dd4ac5f5e20ec7a3bb5ab26bb40b1597da2eafbd8e46454">coda_array_ordering_c</a> or <a class="el" href="group__coda__general.html#gga5585c4e41c797b14f3dd4ac5f5e20ec7a6f530dfe688c288f37ff5bbe2ce1e95b">coda_array_ordering_fortran</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga1dd7a32908ea87ef0740e7c057f76b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dd7a32908ea87ef0740e7c057f76b85">&#9670;&nbsp;</a></span>coda_cursor_read_uint64_partial_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_uint64_partial_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a partial data array as type <code>uint64</code> from the product file. The values are stored in <em>dst</em>. The cursor must point to an array with a base type that has one of the following read types to succeed:</p><ul>
<li><code>uint8</code> </li>
<li><code>uint16</code> </li>
<li><code>uint32</code> </li>
<li><code>uint64</code> </li>
</ul>
<p>For all other data types the function will return an error. Values are both read and returned using C array ordering convention. </p><dl class="section note"><dt>Note</dt><dd>Partial array reading is not supported for HDF5 and HDF4 attributes and HDF4 Vdata. For HDF5 Datasets, HDF4 SDS, and HDF4 GRImage, partial array reading is only allowed when reading a full hyperslab (i.e. the range defined by 'offset' and 'length' should be translatable into a multidimensional start[]/count[], defining a hyperslab) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">offset</td><td>Index (as used in <a class="el" href="group__coda__cursor.html#ga08300afc8797ef5bba44b2acb316bdaf">coda_cursor_goto_array_element_by_index</a>) at which to start reading. </td></tr>
    <tr><td class="paramname">length</td><td>Number of items to read. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the values read from the product will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga1093ca4fe1b54b1f41be2551c34a7c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1093ca4fe1b54b1f41be2551c34a7c28">&#9670;&nbsp;</a></span>coda_cursor_read_uint8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_uint8 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve data as type <code>uint8</code> from the product file. The value is stored in <em>dst</em>. The cursor must point to data with one of the following read types to succeed:</p><ul>
<li><code>uint8</code> </li>
</ul>
<p>For all other data types the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the value that was read from the product will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga85867f3f87e0ab98de72b1e79360d488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85867f3f87e0ab98de72b1e79360d488">&#9670;&nbsp;</a></span>coda_cursor_read_uint8_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_uint8_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__coda__general.html#ga43bbecf10194ddde79f34f1111b7597c">coda_array_ordering</a>&#160;</td>
          <td class="paramname"><em>array_ordering</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a data array as type <code>uint8</code> from the product file. The values are stored in <em>dst</em>. The cursor must point to an array with a base type that has one of the following read types to succeed:</p><ul>
<li><code>uint8</code> </li>
</ul>
<p>For all other data types the function will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the values read from the product will be stored. </td></tr>
    <tr><td class="paramname">array_ordering</td><td>Specifies array storage ordering for <em>dst:</em> must be <a class="el" href="group__coda__general.html#gga5585c4e41c797b14f3dd4ac5f5e20ec7a3bb5ab26bb40b1597da2eafbd8e46454">coda_array_ordering_c</a> or <a class="el" href="group__coda__general.html#gga5585c4e41c797b14f3dd4ac5f5e20ec7a6f530dfe688c288f37ff5bbe2ce1e95b">coda_array_ordering_fortran</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga0a3879eb7d0a4312012a24e647f23afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a3879eb7d0a4312012a24e647f23afc">&#9670;&nbsp;</a></span>coda_cursor_read_uint8_partial_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_read_uint8_partial_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a partial data array as type <code>uint8</code> from the product file. The values are stored in <em>dst</em>. The cursor must point to an array with a base type that has one of the following read types to succeed:</p><ul>
<li><code>uint8</code> </li>
</ul>
<p>For all other data types the function will return an error. Values are both read and returned using C array ordering convention. </p><dl class="section note"><dt>Note</dt><dd>Partial array reading is not supported for HDF5 and HDF4 attributes and HDF4 Vdata. For HDF5 Datasets, HDF4 SDS, and HDF4 GRImage, partial array reading is only allowed when reading a full hyperslab (i.e. the range defined by 'offset' and 'length' should be translatable into a multidimensional start[]/count[], defining a hyperslab) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">offset</td><td>Index (as used in <a class="el" href="group__coda__cursor.html#ga08300afc8797ef5bba44b2acb316bdaf">coda_cursor_goto_array_element_by_index</a>) at which to start reading. </td></tr>
    <tr><td class="paramname">length</td><td>Number of items to read. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the variable where the values read from the product will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga7c6a6c2bac64e9ab3f9b71d178a3e04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c6a6c2bac64e9ab3f9b71d178a3e04d">&#9670;&nbsp;</a></span>coda_cursor_set_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_set_product </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__coda__product.html#gaaf31b4b329a9b03d6e7e7a386c466cf6">coda_product</a> *&#160;</td>
          <td class="paramname"><em>product</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the cursor to point to the entire product. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
    <tr><td class="paramname">product</td><td>Pointer to a product file handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Succes. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaa58abc3d22330e5d322c9f8147a99d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa58abc3d22330e5d322c9f8147a99d2e">&#9670;&nbsp;</a></span>coda_cursor_use_base_type_of_special_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coda_cursor_use_base_type_of_special_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__coda__cursor.html#ga86506368d642120e9491eee25e45c2de">coda_cursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinterpret the current special data type using the base type of the special type. All data types with a type class <a class="el" href="group__coda__types.html#ggaa4d9bef64d23de166a5e0249504f5afaa5d605b83d52f350f6525d9ee8576f34f">coda_special_class</a> have a base type that can be used to read the data in its raw form (e.g. for ascii time data the type will change to a string type and for binary compound time data the type will change to a record with fields containing binary numbers). With this function the cursor is modified such that it will interpret the current data element using this base type. The cursor should point to data of class <a class="el" href="group__coda__types.html#ggaa4d9bef64d23de166a5e0249504f5afaa5d605b83d52f350f6525d9ee8576f34f">coda_special_class</a> or an error will be returned. </p><dl class="section warning"><dt>Warning</dt><dd>Using <a class="el" href="group__coda__cursor.html#gadbb9fba27af87d3b854194316a1f8c08">coda_cursor_goto_parent()</a> on the cursor after calling <a class="el" href="group__coda__cursor.html#gaa58abc3d22330e5d322c9f8147a99d2e">coda_cursor_use_base_type_of_special_type()</a> will move the cursor to the parent of the special type and not back to the special type itself. In other words, <a class="el" href="group__coda__cursor.html#gaa58abc3d22330e5d322c9f8147a99d2e">coda_cursor_use_base_type_of_special_type()</a> does not 'move' the cursor, it only changes the data type that is used to interpret the underlying data. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Pointer to a CODA cursor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code>, Success. </li>
<li><code>-1</code>, Error occurred (check <a class="el" href="group__coda__error.html#gafcb445c7fcab2d4d0af01f0e1c2dc866">coda_errno</a>). </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
<div class="footer">
<hr><p>Copyright &copy; 2007-2021 <b>s<span class="soft-red">[</span>&amp;<span class="soft-red">]</span>t</b>, The Netherlands.
</p>
</div>
</div>
</body>
</html>
